/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */
/*******************************************************************************
  Changes:

  - Date   -  UID  --------------------- Description ---------------------
  09/29/2016  ecl  BUG268560: Account for multi-byte characters when getting 
                   the number of bytes in a string.  Also allow allocateBuffer
                   to allocate more than 1024 at a time.
 ******************************************************************************/

"use strict";

var os = require('os'),
	logger = require('../trace-output-tcp'),
    msgcon = require('../protocol/constants'),
    traceConfig = require('../trace-config');


//-----------------------------
//Internal Variables
//-----------------------------

var logLocation = 'protocol-util',
	endianness = exports.endianness = (os.endianness() === 'BE'?msgcon.Encoding.BinaryBigEndian:msgcon.Encoding.BinaryLittleEndian);

//var buffer1024 = new Buffer(1024);

//-----------------------------
//Internal Functions
//-----------------------------

//-----------------------------
//External Functions
//-----------------------------
var getStringBytes = exports.getStringBytes = function(string) {

    // Default encoding is UTF-8.
	return Buffer.byteLength(string);
}

//TODO - keep some pre-allocated buffers around to re-use????
//TODO - Figure out how the tcp send actually works - if socket.some_variable indicates buffer has been flushed can we re-use?
//  e.g. should we allocate a pool of buffers and just re-use them

var allocateBuffer = exports.allocateBuffer = function(size, bufferToConcat) {

	//TODO throw an exception if this fails 
	
	//logger.logDebug(logLocation+'.allocateBuffer', 'requested size:'+size);

	var buffer;
	if (bufferToConcat !== undefined) {
		logger.logDebug(logLocation+'.allocateBuffer', 'concatenating buffers');
		//TODO is this a reasonable #
		// enlarging a buffer - always allocate in min of 1024 chunks
		size = (size < 1024) ? 1024 : size;
		buffer = Buffer.concat([bufferToConcat, new Buffer(size)], (bufferToConcat.length+size));
	}
	else {
		// Transport header is 8 bytes and a max msg header length is 29 bytes
		// Make sure msg length is at least 128 bytes long - this seems reasonable
		size = (size < 128) ? 128 : size;
		//logger.logDebug(logLocation+'.allocateBuffer', 'allocating a new buffer:'+size);

		// new buffer - allocate size requested
		buffer = new Buffer(size);
	}
	return buffer;
}

var checkBufferCapacity = exports.checkBufferCapacity = function(buffer, capacityNeeded) {
	//logger.logDebug(logLocation+'.checkBufferCapacity', 'bufLen:'+buffer.length+'   capacityNeeded:'+capacityNeeded);
	if (capacityNeeded > buffer.length) {
		buffer = allocateBuffer(capacityNeeded, buffer);
		logger.logDebug(logLocation+'.checkBufferCapacity', 'BUFFER EXPANDED');
	}
	return buffer;
}

var writeInteger = exports.writeInteger = function(value, buffer, offset, length) {

	var nextPos = offset;

	if(typeof buffer.writeUIntBE === 'function') {
		
		//Version: v0.12.5 for example

		// writeIntBE and writeIntLE returns next position
		switch(endianness) {
		
			case msgcon.Encoding.BinaryBigEndian :
				nextPos = buffer.writeUIntBE(value, offset, length);
				break;
			case msgcon.Encoding.BinaryLittleEndian :
				nextPos = buffer.writeUIntLE(value, offset, length);
				break;
			default:
				//TODO  something
				//logger.logError(logLocation+'.writeInteger', 'Unsupported encoding(v4):'+endianness);
		}
	} else {
		
		// Version 0.10.38 for example
		
		// writeUInt16BE and writeUInt32BE, et al returns next position
		switch(endianness) {
		
			case msgcon.Encoding.BinaryBigEndian :
				switch (length) {
					case 1:
						buffer.writeInt8(value, offset);
						nextPos += 1;
						break;
					case 2:
						buffer.writeUInt16BE(value, offset);
						nextPos += 2;
						break;
					case 4:
						buffer.writeUInt32BE(value, offset);
						nextPos += 4;
						break;
					default:
						//TODO  something
						//logger.logError(logLocation+'.writeInteger', 'Unsupported length(BE):'+length);
				}
				break;
			case msgcon.Encoding.BinaryLittleEndian :
				switch (length) {
					case 1:
						buffer.writeInt8(value, offset);
						nextPos += 1;
						break;
					case 2:
						buffer.writeUInt16LE(value, offset);
						nextPos += 2;
						break;
					case 4:
						buffer.writeUInt32LE(value, offset);
						nextPos += 4;
						break;
					default:
						//TODO  something
						//logger.logError(logLocation+'.writeInteger', 'Unsupported length(LE):'+length);
				}
				break;
			default:
				//TODO  something
				//logger.logError(logLocation+'.writeInteger', 'Unsupported encoding(v10):'+endianness);
		}
	}
	return nextPos;
}

var readInteger = exports.readInteger = function(buffer, offset, length, endian) {

	var thisEndian = (endian === undefined) ? endianness : endian;
	var intValue;
	if(typeof buffer.writeUIntBE === 'function') {
		
		//Version: v0.12.5 for example

		switch(thisEndian) {
		
			case msgcon.Encoding.BinaryBigEndian :
				intValue = buffer.readUIntBE(offset, length);
				break;
			case msgcon.Encoding.BinaryLittleEndian :
				intValue = buffer.readUIntLE(offset, length);
				break;
			default:
				//TODO  something
				logger.logError(logLocation+'.readInteger', 'Unsupported encoding(v4):'+endianness);
		}
	} else {
		
		// Version 0.10.38 for example
		
		// writeUInt16BE and writeUInt32BE, et al returns next position
		switch(endianness) {
		
			case msgcon.Encoding.BinaryBigEndian :
				switch (length) {
					case 1:
						intValue = buffer.readUInt8(offset);
						break;
					case 2:
						intValue = buffer.readUInt16BE(offset);
						break;
					case 4:
						intValue = buffer.readUInt32BE(offset);
						break;
					default:
						//TODO  something
						logger.logError(logLocation+'.readInteger', 'Unsupported length(BE):'+length);
				}
				break;
			case msgcon.Encoding.BinaryLittleEndian :
				switch (length) {
					case 1:
						intValue = buffer.readUInt8(offset);
						break;
					case 2:
						intValue = buffer.readUInt16LE(offset);
						break;
					case 4:
						intValue = buffer.readUInt32LE(offset);
						break;
					default:
						//TODO  something
						logger.logError(logLocation+'.readInteger', 'Unsupported length(LE):'+length);
				}
				break;
			default:
				//TODO  something
				logger.logError(logLocation+'.readInteger', 'Unsupported encoding(v10):'+endianness);
		}
	}
	return intValue;
}

var writeFloat = exports.writeFloat = function(value, buffer, offset) {

	// writeFloatLE and writeFloatBE returns next position
	switch(endianness) {
	
		case msgcon.Encoding.BinaryBigEndian :
			buffer.writeFloatBE(value, offset);
			break;
		case msgcon.Encoding.BinaryLittleEndian :
			buffer.writeFloatLE(value, offset);
			break;
		default:
			//TODO  something
			logger.logError(logLocation+'.writeFloat', 'Unsupported encoding:'+endianness);
	}
	return offset + 4;
}

var writeDouble = exports.writeDouble = function(value, buffer, offset) {

	// writeDoubleLE and writeDoubleBE returns next position
	switch(endianness) {
	
		case msgcon.Encoding.BinaryBigEndian :
			buffer.writeDoubleBE(value, offset);
			break;
		case msgcon.Encoding.BinaryLittleEndian :
			buffer.writeDoubleLE(value, offset);
			break;
		default:
			//TODO  something
			logger.logError(logLocation+'.writeDouble', 'Unsupported encoding:'+endianness);
	}
	return offset + 8;
}

//char set  is UTF-8
var writeMsgString = exports.writeMsgString = function(msg, buffer, offset) {
	// returns next position
	var nextOffset = writeInteger(Buffer.byteLength(msg), buffer, offset, 4);
	// returns # of octets written
	nextOffset += buffer.write(msg, nextOffset, Buffer.byteLength(msg));
	// return next position
	return nextOffset;
}

//char set  is UTF-8
var readMsgString = exports.readMsgString = function(buffer, offset, endian) {
	var length = readInteger(buffer, offset, 4, endian);
	var str = "";
	if (length > 0) {
		offset += 4;
		//==============
		// returns # of octets written
		str = buffer.toString('utf8',offset, offset+length);
	}
	return str;
}

// write a 16-byte uuid (128 bit)
var writeUuid128 = exports.writeUuid128 = function(uuid, buffer, offset) {
	// Server reads UUID back as 2 longs, we don't have long (64-bit) precision 

	// No need to check that length is 16 bytes now - we control that
	
	switch(endianness) {
	
		case msgcon.Encoding.BinaryBigEndian :
			// just copy bytes from 0 -15
			uuid.copy(buffer, offset);
			break;
		case msgcon.Encoding.BinaryLittleEndian :
			// copy bytes so they can be read as two longs
			var targetIndex = offset;
			var srcIndex;
			for (srcIndex = 7; srcIndex >=0; srcIndex--) {
				buffer[targetIndex++] = uuid[srcIndex];
			}
			for (srcIndex = 15; srcIndex >=8; srcIndex--) {
				buffer[targetIndex++] = uuid[srcIndex];
			}
			break;
		default:
			//TODO  something
			//logger.logError(logLocation+'.writeUuid128', 'Unsupported encoding:'+endianness);
	}
	return (offset+16);
}

//read a 16-byte uuid (128 bit)
var readUuid128 = exports.readUuid128 = function(buffer, offset) {
	// Server writes UUID as 2 longs, we don't have long (64-bit) precision 

	// No need to check that length is 16 bytes now - we control that
	
	var uuid = new Buffer(16);
	
	switch(endianness) {
	
		case msgcon.Encoding.BinaryBigEndian :
			// just copy bytes from 0 -15
			buffer.copy(uuid, 0, offset, offset+16);  // target, target start, source start, source end
			break;
		case msgcon.Encoding.BinaryLittleEndian :
			// copy bytes so they can be read as two longs
			var srcIndex = offset;
			var targetIndex = 0;
			for (srcIndex = offset+7; srcIndex >=offset; srcIndex--) {
				uuid[targetIndex++] = buffer[srcIndex];
			}
			for (srcIndex = offset+15; srcIndex >=offset+8; srcIndex--) {
				uuid[targetIndex++] = buffer[srcIndex];
			}
			break;
		default:
			//TODO  something
			logger.logError(logLocation+'.readUuid128', 'Unsupported encoding:'+endianness);
	}
	return (uuid);
}

var writeVersion = exports.writeVersion = function(buffer, offset, majorVersion, minorVersion) {
	var nextPos = offset;
	nextPos = writeInteger(majorVersion, buffer, nextPos, 2);
	nextPos = writeInteger(minorVersion, buffer, nextPos, 2);
	return nextPos;
}

var dumpBuffer = exports.dumpBuffer = function (buffer, offset) {
	
	// don't construct the string unless DEBUG is on
	if (traceConfig.LOGGING_LEVELS.DEBUG) {
		var bufStr = "buffer = ";
		
		for (var index = 0; index < offset; index++) {
			bufStr += buffer[index].toString(16);
		}
		logger.logDebug(logLocation+'.dumpBuffer', bufStr);
	}
}
