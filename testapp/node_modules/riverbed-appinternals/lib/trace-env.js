/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// Environmental Metrics Module
// *****************************

// required modules
var traceEventloop = require('./trace-eventloop'),
	traceMoniker = require('./trace-moniker'),
	traceOutput = require('./trace-output-api'),
	traceHttp = require('./trace-http'),
	traceFs = require('./trace-fs'),
	traceUtil = require('./trace-util'),
	traceConfig = require('./trace-config'),
	pusage = require('pidusage'),
	blocked = require('blocked'),
	EventEmitter = require('events').EventEmitter;

// -----------------------------
// Constants
// -----------------------------

var metricCaptureIntervalMs = 5000;		// every 5 secs. NOTE: can adjust, but should be > 0!
var processMetricClearInterval = 60000,	// every minute
	processLastClearTime;	
		
// -----------------------------
// Internal Variables
// -----------------------------

var lastCaptureTime,
	captureSocketIO = false,
	captureGC = false,
	traceSocketIO,
	currentlyShortCircuited,
	captureTimeout,
	lastCPUStats={
		cpu:0.0,
		system:0.0,
		user:0.0
	},
	lastGCStats=[];

// -----------------------------
// Internal Functions
// -----------------------------

function captureMetrics() {
	// new timestamp and calculate capture timespan
	var currentTime = traceUtil.getHrTimeMs(),
		spanSec = (currentTime - lastCaptureTime) / 1000.0;

		// trigger capture of process-level metrics
		captureProcessMetrics();

		// calc memory values
		var mem = process.memoryUsage(),
			usedMem = mem.rss ? mem.rss / 1048576.0 : 0.0,				// Convert bytes to MBs
			usedHeap = mem.heapUsed ? mem.heapUsed / 1048576.0 : 0.0,	// Convert bytes to MBs
			usedNonHeap = Math.max(usedMem - usedHeap, 0.0);			// already converted, normalize to be non-neg

		// calc GC values
		var totalMbCollected = 0.0,
			totalSecsGC = 0.0;

		for (var gcIdx=0; gcIdx<lastGCStats.length; gcIdx++) {
			if(lastGCStats[gcIdx]){
				if(lastGCStats[gcIdx].diff && lastGCStats[gcIdx].diff.usedHeapSize) {
					// Convert bytes to MBs
					// divisor is negative because the change in "diff" is negative
					totalMbCollected += (lastGCStats[gcIdx].diff.usedHeapSize / -1048576.0); 
				}
				if (lastGCStats[gcIdx].pause) {
					totalSecsGC += (lastGCStats[gcIdx].pause / 1000000000.0); 	// convert nanos to secs
				}
			}
		}

		// output event loop and memory usage metrics
		var result = {
			'moniker': traceMoniker.getProcessMoniker(),
			'pid':process.pid,
			'endTime': Date.now(),
			'timespanSec': spanSec,
	        'Memory Management': {
	        	'MBs in use':usedMem,
	        	'Heap MBs in use':usedHeap,
	        	'non-Heap MBs in use':usedNonHeap,
	        	'garbage collections / sec': lastGCStats.length / spanSec,
	        	'MBs consumed / sec': totalMbCollected / spanSec,
	        	'% time garbage collecting': totalSecsGC / spanSec
	        },
	        'Process#CPU': {
	        	'Busy (%)':((lastCPUStats && lastCPUStats.cpu)?lastCPUStats.cpu:0.0),
	        	'System (%)':((lastCPUStats && lastCPUStats.system)?lastCPUStats.system:0.0),
	        	'User (%)':((lastCPUStats && lastCPUStats.user)?lastCPUStats.user:0.0)
	        },
	        'Process#I/O' : {
	        	'Total (MB)': 			(traceFs.getBytesRead() + traceFs.getBytesWritten()) / 1000000,		// convert bytes to MB
	        	'Read Total (MB)': 		traceFs.getBytesRead() / 1000000,									// convert bytes to MB
	        	'Write Total (MB)':  	traceFs.getBytesWritten() / 1000000,								// convert bytes to MB
	        	'Other Total (MB)': 	0.0																	// don't have "other" currently
	        }
		};

		if(traceConfig.isMonitorEventLoop()) {
			result.eventLoop = traceEventloop.getResults();
		}
		
		// Assuming we want to "hold" the last CPU value if we don't get an update before the next call to this function
		// Otherwise, if we wanted to zero when we don't get an update, we should zero the values for lastCPUStats here.
		
		// Need to clear out GC stats, so we don't use stale values in next cycle
		lastGCStats = [];

		result.httpRequests = {
			'inbound':{
				'loadPerSec':traceHttp.getTotalInboundRequestCount() / spanSec,
				'concurrent':traceHttp.getCurrentInboundRequestCount()
			},
			'outbound':{
				'loadPerSec':traceHttp.getTotalOutboundRequestCount() / spanSec,
				'concurrent':traceHttp.getCurrentOutboundRequestCount()
			}
		};
		if(captureSocketIO) {
			result.socketio = {
				'connections': traceSocketIO.getTotalConnections(),				// this is all connections made, not just since the last recording
				'currentConnections': traceSocketIO.getCurrentConnections(),
				'messagesReceived': traceSocketIO.getTotalMessagesReceived(),	// this is all messages received, not just since the last recording
				'receivedAvgChars': 											// average over all messages, not just those since last recording
					((traceSocketIO.getTotalMessagesReceived()>0)? 
						traceSocketIO.getTotalCharsReceived() / traceSocketIO.getTotalMessagesReceived() : 
						0),
				'messagesSent': traceSocketIO.getTotalMessagesSent(),		// this is all messages sent, not just since the last recording
				'sentAvgChars': 											// average over all messages, not just those since last recording
					((traceSocketIO.getTotalMessagesSent()>0)? 
						traceSocketIO.getTotalCharsSent() / traceSocketIO.getTotalMessagesSent() : 
						0)
			};
		}
		traceOutput.addEnvResult(result);
	// need to reset the stats/counters before calc-ing the next batch
	if(traceConfig.isMonitorEventLoop()) {
		traceEventloop.clearResults();
	}
	traceHttp.clearRequestMetrics();
	traceFs.clearResults();

	// update last capture time
	lastCaptureTime = currentTime;

	// set timer for next capture
	captureTimeout = setTimeout(captureMetrics,metricCaptureIntervalMs);
};

function captureProcessMetrics(){
	// Don't need to worry about short-circuiting here
	// captureMetrics will only trigger this capture if NOT currently short-circuited
	// if the capture results come back after instrumentation has been toggled to short-circuited then the output module will just throw them away.
	//
	// NOTE: from looking at the source, pidusage uses child processes to exec the commands, so we shouldn't need to put this in a separate process ourselves.
	pusage.stat(process.pid, function(err, stat) {
		
		var endTime = Date.now();

		if(err) {
			traceOutput.error("env.instrumentProcessUsage","Could not obtain process-level metrics: "+err);
		} else {
			// update stats that will be picked up in captureMetrics
			if(stat) {
				lastCPUStats = stat;
			}
		}

	 	// should we clear the history? want to do this occaisonally to not use too much memory if process is really long running
	 	if((endTime - processLastClearTime) > processMetricClearInterval) {
	 		pusage.unmonitor(process.pid);
	 		processLastClearTime = endTime;
	 	}	 
	});
};

function handleBlockedEventloop(lag){
	// don't collect any data if we're short-circuited
	if(!traceConfig.isShortCircuited()) {
		//TODO: In the future we may want to trigger CPU profiling for a period of N ms whenever we detect a blocked eventloop
		// For now, just write out an environmental metric
		// Note: the 'blocked' nodule checks every 100ms and triggers if the lag is > 10ms. 
		// If we want the checking interval to be configurable or threshold to be configurable, we could fork blocked (MIT License)
		traceOutput.addEnvResult({
			'moniker': traceMoniker.getProcessMoniker(),
			'pid':process.pid,
			'endTime': Date.now(),
			'eventLoopLagMs': lag
		});
	}
};

// -----------------------------
// External Functions
// -----------------------------

exports.init = function(opts){
	currentlyShortCircuited = traceConfig.isShortCircuited();
	if(traceConfig.isMonitorEventLoop()) {
		traceEventloop.instrumentEventLoop();
	}
	traceFs.instrumentFs();
	blocked(handleBlockedEventloop);
	lastCaptureTime = traceUtil.getHrTimeMs();
	processLastClearTime = Date.now();
	// don't collect any data if we're short-circuited
	if(!currentlyShortCircuited) {
		captureMetrics();
	}
};

exports.enableSocketIoCollection = function(enabled){
	if(enabled){
		traceSocketIO = require('./trace-socketio');
	}
	captureSocketIO = enabled;
};

exports.instrumentGC = function(requiredMod){
	// don't double register for GC stats
	if(!captureGC) {
		var gc=null;
		try {
			// gc-stats API < v1.0
			gc = new (require(requiredMod))();
		} catch(err) {
			gc = null;
			try {
				// gc-stats API >= v1.0
				gc = (require(requiredMod))();
			} catch(err2) {
				gc = null;
				traceOutput.error("env.instrumentGC","Could not connect gc-stats: "+err);
			}
		}

		if(gc != null) {
			captureGC = true;
			try {
				gc.on('stats', function (stats) {
					// don't collect any data if we're short-circuited
					if(!traceConfig.isShortCircuited()) {
						// update stats that will be picked up in captureMetrics
						if(stats){
							lastGCStats.push(stats);					
						}
					}
				});
			} catch(err) {
				traceOutput.error("env.instrumentGC","Could not collect gc-stats: "+err);
			}
		}
	}
};

exports.updateShortCircuiting =function() {

	// check that current short circuit state is different from current one
	// to prevent duplicate toggling of shortCircuit from on to on or from off to off
	// that could potentially cause bad things to happen
	// e.g. multiple timeOuts going for collecting data
	if(currentlyShortCircuited != traceConfig.isShortCircuited()) {
		// update current short circuit status
		currentlyShortCircuited = traceConfig.isShortCircuited();
		if(currentlyShortCircuited) {
			// need to do short circuiting
			// this is handled by
			// (1) updating status flag done above
			// (2) cancelling the timeOut
			if(captureTimeout) {
				clearTimeout(captureTimeout);
			}
			// (3) clear history to free up resources from pidusage
			pusage.unmonitor(process.pid);
		} else {
			// need to rewire so short circuiting is off
			// this is handled by
			// (1) updating status flag done above
			// (2) reset last time values
			lastCaptureTime = traceUtil.getHrTimeMs();
			processLastClearTime = Date.now();
			// (3) call captureMetrics
			captureMetrics();
		}
	}
};