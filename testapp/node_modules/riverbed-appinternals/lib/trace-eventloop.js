/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// Eventloop stats Module
// *****************************

// required modules
var traceCLS = require('./trace-cls'),
	traceConfig = require('./trace-config'),
	traceUtil = require('./trace-util'),
	traceOutput = require('./trace-output-api');

function resetStats() {
	return {
		tickCount:0,
		tickTotalDur:0,
		minTickDur:0,
		minTickGap:0,
		startedCount:0,
	};
};

var stats = resetStats(),
	lastTickDone;

var listenerFunctions = {
	create:function(storage){},
	before:function(context,storage){
		// don't collect anything if we are currently short-circuited
		if(!traceConfig.isShortCircuited()) {
			// start time
			storage.start = Date.now();

			// started count
			stats.startedCount++;
			
			// gap between end and start
			var gap = storage.start - lastTickDone;
			// update max if not yet set or this is greater
			if(!stats.maxTickGap || gap > stats.maxTickGap) {
				stats.maxTickGap = gap;
			}
			if(gap < stats.minTickGap) {
				stats.minTickGap = gap;
			}

			// see if we're in the CLS context of some trace
			var data = traceCLS.getData();
			if(data && !data.finished) {
				// see if the async callback about to be executed has a name
				// if it does, add it to the list of callbacks for this trace
				if(context.__originalname) {

			        traceOutput.addTraceResult({
			        	'type' 		: 'start',
			        	'txId' 		: data.txId,
			        	'category'	: 'Generic',
			        	'file'		: '',
			        	'method'	: context.__originalname,
			        	'time'		: storage.start,
			        	'props' 	: []
			        });
			        // increment open call count
		        	data.callDepth++;
			        // add an array to track exceptions for this call
					traceUtil.safePushExceptionsStack(data,[]);
				}
			}
		}
	},
	after:function(context,storage){
		// don't collect anything if we were short-circuited at before time
		// or if currently short-circuited
		if(storage.start && !traceConfig.isShortCircuited()) {
			// end time
			storage.end = Date.now();

			// done count
			stats.tickCount++;

			// duration of tick
			var dur = storage.end - storage.start;
			// update max if not yet set or this is greater
			if(!stats.maxTickDur || dur > stats.maxTickDur) {
				stats.maxTickDur = dur;
			}
			if(dur < stats.minTickDur) {
				stats.minTickDur = dur;
			}
			stats.tickTotalDur+=dur;

			// see if we're in the CLS context of some trace
			var data = traceCLS.getData();
			if(data && !data.finished){ 
				// see if the async callback about to be executed has a name
				// if it does, add it to the list of callbacks for this trace
				if(context.__originalname) {
					traceOutput.addTraceResult({
			        	'type' 			: 'end',
			        	'txId' 			: data.txId,
			        	'time'			: storage.end,
			        	'props' 		: [],
			        	'exceptions' 	: traceUtil.safePopExceptionsStack(data)
			        });
			        // decrement open call count
		        	data.callDepth--;
				}
			}
		}
		// update last tick done time
		// want to do this even if short-circuited so we have an accurate value to use when rewiring
		lastTickDone = Date.now();
		// clear out storage
		storage.start = null;
		storage.end = null;
	}
};

// -----------------------------
// External Functions
// -----------------------------

var getResults = exports.getResults = function() {
	stats.avgTickLength = (stats.tickCount==0)?0:stats.tickTotalDur/stats.tickCount;
	return stats;
};

var clearResults = exports.clearResults = function() {
	stats = resetStats();
};

exports.instrumentEventLoop = function(){
	// make sure async-listener is loaded
	if(!process.addAsyncListener)
		require('async-listener');

	// initialize the last done time
	lastTickDone = Date.now();

	traceCLS.bind(listenerFunctions.create);
	traceCLS.bind(listenerFunctions.before);
	traceCLS.bind(listenerFunctions.after);

	process.addAsyncListener(listenerFunctions,{});
};