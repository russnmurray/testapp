/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// Output Module
// *****************************

// required modules
var fs = require('fs'),
	path = require('path'),
	traceOutput = require('./trace-output-api'),
	os = require('os');

// -----------------------------
// Constants
// -----------------------------

// file extension for saving results
var traceFileExtension = ".traces.json",
	envFileExtension = ".env.json",
	profileFileExtension = ".cpuprofile",
	snapshotFileExtension = ".heapsnapshot";

// -----------------------------
// Internal Variables
// -----------------------------

// A queue to push finished transactions to until we can persist them
var traceQueue = [],
	envQueue = [],
	traceWriteIntervalMs = 1000,	// write traces every second
	envWriteIntervalMs = 5000,		// write env data every 5 seconds
	traceStream,
	envStream,
	outputPath;

// -----------------------------
// Internal Functions
// -----------------------------

// Write batched results to disk
// the while loop is guaranteed not to be interreputed since execution of OUR code is single threaded.
// that means that we don't have to worry that things will be added to the queue while we're still in the loop
// however, the actually FS I/O from writing to the stream should happen in a separate thread.
// effectively this means that we quickly rip through the queue (in a blocking way) and *initiate* the I/O
// but then the I/O happens in a separate thread in a non-blocking async way.

function persistTraceResults() {

	if(traceQueue.length>0) {
		while (traceQueue.length > 0) {
			traceStream.write(', '+traceQueue.shift()+'\n');
		}
	}

	// check again for batch of results after interval
	setTimeout(persistTraceResults,traceWriteIntervalMs); 
};

function persistEnvResults() {
	if(envQueue.length>0) {
		while (envQueue.length > 0) {
			envStream.write(envQueue.shift()+'\n');
		}
	}

	// check again for batch of results after interval
	setTimeout(persistEnvResults,envWriteIntervalMs); 
};

// -----------------------------
// External Functions
// -----------------------------

// Set up stream for writing results to disk
// This should be called before add*Result is ever called
var init = exports.init = function (outputPath,moniker) {
	traceOutput.debug('trace-output-file.init','writing results for moniker '+moniker+' to directory '+outputPath);
	traceOutput.debug('trace-output-file.init','creating output streams');
	// create output stream w/ utf-8 encoding and flags a+ to 
	// (1) append if file exists (2) create file if it doesn't exist
	traceStream = fs.createWriteStream(path.join(outputPath,moniker+traceFileExtension), {encoding:'utf-8', flags: 'a+'});
	envStream = fs.createWriteStream(path.join(outputPath,moniker+envFileExtension), {encoding:'utf-8', flags: 'a+'});
	// once the steram has been opened, kick off polling for results at an interval
	traceStream.on("open",persistTraceResults);
	envStream.on("open",persistEnvResults);
};

var shutdown = exports.shutdown = function() {
	//Should close streams before process exits
	if(traceStream){
		traceStream.end();
	}
	if(envStream) {
		envStream.end();
	}
};

// push the result onto the queue now to get persisted at some point
var addTraceResult = exports.addTraceResult = function(tracingData) {
	traceQueue.push(JSON.stringify(tracingData));
};

var addEnvResult = exports.addEnvResult = function(envData) {
	envQueue.push(JSON.stringify(envData));
};

var persistProfileResult = exports.persistProfileResult = function(profilesPath,moniker,profileId,profile) {
	var profileFile = path.join(profilesPath,moniker+'-'+profileId+profileFileExtension);
	fs.writeFile(profileFile,JSON.stringify(profile),function(err){
		if(err) {
			traceOutput.error('trace-output-file','failed to write profile file: '+profileFile);
		} else {
			traceOutput.debug('trace-output-file','wrote profile file: '+profileFile);
		}
		// delete profile now 
		profile.delete();
	});
};

var persistSnapshotResult = exports.persistSnapshotResult = function(snapshotsPath,moniker,snapshotId,snapshot) {
	var snapshotFile = path.join(snapshotsPath,moniker+'-'+snapshotId+snapshotFileExtension);
	traceOutput.debug('trace-output-file','writing heap snapshot to file '+snapshotFile);
	var snapshotStream = fs.createWriteStream(snapshotFile);
	snapshotStream.on("open",function(){
		snapshot.serialize(
			function iterator(data, length) {
				snapshotStream.write(data);
			},
			function callback() {
		  		snapshotStream.end();
		  		// delete snapshot now 
		  		snapshot.delete();
		  		traceOutput.debug('trace-output-file','wrote heap snapshot to file '+snapshotFile);
			}
		);
	});
};