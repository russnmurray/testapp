/* ****************************
** Copyright (c) 2017        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */
/*******************************************************************************
  Changes:

  - Date   -  UID  --------------------- Description ---------------------
  09/29/2016  ecl  BUG268560: Account for multi-byte characters when getting
                   the number of bytes in a string.
 ******************************************************************************/

"use strict";

//*****************************
// TCP Output Module
// Runs as a child process and
// manages the transfer of trace and metric data to the Node DA
//
// A note about logging:  Log msgs are sent to the Node DA for logging
// based on the severity of the msg and the current log level
// (ERROR,WARN,INFO,DEBUG). This can only happen after this client
// receives a session id from the DA. Log msgs in the code that might
// be executed prior to receiving a session id (such as those in the
// client socket connection code) will be ignored unless debug=true
// is on, in which case they will be printed to the console.
//*****************************

var net = require('net'),
	os = require('os'),
	traceConfig = require('./trace-config'),
    msgcon = require('./protocol/constants'),
    transportHdr = require('./protocol/transportHeader'),
	msgUtil = require('./protocol/util'),
	msgHeader = require('./protocol/messageHeader'),
	session = require('./protocol/sessionMsgs'),
	trace = require('./protocol/callTraceMsgs'),
	traceProps = require('./protocol/trace-props'),
	msgConfig = require('./protocol/configMsgs'),
	metrics = require('./protocol/metrics'),
	metricData = require('./protocol/sampleData'),
	metricDefs = require('./protocol/metricGroup'),
	dockerSupport = require('./docker/docker-support.js');

//-----------------------------
//Constants
//-----------------------------

var logLocation = 'trace-output-tcp';
var DEFAULT_PORT = 7072;		// Node DA
var DEFAULT_HOST = "localhost";	// Node DA

//-----------------------------
//Internal Variables
//-----------------------------

var traceQueue = [],
	envQueue = [],
	rcvdDataChunks = [],
	traceWriteIntervalMs = 1000,	// write traces every second
	envWriteIntervalMs = 1000,		// write env data every second
	host,
	port,
	moniker,
	pid,
	clientSocketRetryId = 0,
	clientSocket = -1,
	//TODO Can I use clientSocket.remotePort  here instead of my own variable???
	clientSocketConnected = false,
	traceSocket = -1,
	traceSocketConnected = false,
	// the net.socket connect Listener is removed once a connection is made;
	// his variable used to determine if we need to register a new listener
	attemptingReconnect = true,
    sessionId = -1,
    envProperties = undefined,
    initedEnvProps = false,
    // next two variables track when some initialization
    // is complete after a session has been established
    tracePropsSent = false,
    numMetricGroupsLeft = -1,   // set to some #, we will reset when we know how many and count down to 0
    logCount = 0;

// -----------------------------
// Internal Functions
// -----------------------------

function onClientConnect() {
	// Note - we cannot log to the DA yet because we have no sessionId.
	// Log msgs in this method will only be logged in DEBUG mode
	clientSocketRetryId = 0;
	clientSocketConnected = true;
	logInfo(logLocation+'.onClientConnect', 'Client socket connected to:'+host+':'+port);
	logCount = 0;
	//Start a Session
	beginSession();
}

function onTraceConnect() {
	traceSocketConnected = true;
	logInfo(logLocation+'.onTraceConnect', 'Trace socket connected to:'+host+':'+port);
	completeSessionInit();
}

function completeSessionInit() {
	// wait until other init tasks are complete
	if (!tracePropsSent && numMetricGroupsLeft !== 0) {
		setTimeout(completeSessionInit, 1000);
	} else {
		updateConfig();
	}
}

// reset process variables and attempt to reconnect to DA
function onTcpReset() {
	// reconnect attempts are triggered by a socket close or a socket end event
	// if a socket end results in an error, a close is also issued
	// make sure we aren't already trying to reconnect
	if (clientSocketRetryId === 0) {

		// re-init stuff before logging to prevent stack overflow
		traceConfig.setDAConnected(false);
		traceConfig.setShortCircuited(true);
		process.send({'type':'shortcircuit','isShortCircuit':traceConfig.isShortCircuited()});
		process.send({'type':'daConnectState','connected':traceConfig.isDAConnected()});

		// reset all variables so we can reconnect

		// setting these to 0 essentially flushes the queue
		traceQueue.length = 0;
		envQueue.length = 0;
		rcvdDataChunks.length = 0;

		clientSocketConnected = false;
		traceSocketConnected = false;
		sessionId = -1;
		initedEnvProps = false;
		tracePropsSent = false;
		numMetricGroupsLeft = -1;

		// now try to reconnect()
		clientSocketRetryId = setTimeout(function() {
			// we already have a connection listener, just connect
			clientSocketRetryId = 0;
		    logInfo(logLocation+'.onTcpReset', 'Attempting to reconnect client');
		    initClientSession();
		},5000);
	}
//	else {
//		// Yes we cannot log yet because we have no sessionId - this will only be logged in DEBUG mode
//		logInfo(logLocation+'.onTcpReset', 'Attempting to reconnect to Client socket');
//	}
}

function initClientSession() {

	// Returns a new socket and attempts a connect
	//The connectListener parameter will be added as a listener for the 'connect' event once.
	clientSocket = net.connect(port, host, onClientConnect);

	// Add a 'data' event handler for the client socket
	// 'data' is what the server sent to this socket
	clientSocket.on('data', function(data) {
		logDebug(logLocation+'.initClientSession', 'Received data on client socket');
		rcvdDataChunks.push(data);
		onTcpData();
	});

	//Add an 'error' event handler for the client socket
	clientSocket.on('error', function(e) {

		// Emitted when an error occurs. The 'close' event will be called directly following this event.

		// Set this to stop logging
		clientSocketConnected = false;
		// set connected state - we'll tell the instrumentation code in onTcpReset()
		traceConfig.setDAConnected(false);

		// On nodeJS 0.10.38 running on Linux, we only get this error the first time we attempt to
		// reconnect. After that we get no error and a CLOSE event (not sure if it is Linux or the version of node)
		// Yes we can't actually log to the DA BUT if we are in debug mode, we will print to the console
		if(e.code === 'ECONNREFUSED') {
			// close event always follows an error event - attempt to reconnect there

			//Don't fill up the console screen, just print every 30th time
			if (logCount++ % 30 === 0) {
				logCount = (logCount === 31) ? 0 : logCount;
				logError(logLocation+'.initClientSession', 'Client could not connect to DA; Error code:'+e.code);
				logWarn(logLocation+'.initClientSession', 'Client Connection refused; reconnect will be attempted.');
			}
		} else {
			logError(logLocation+'.initClientSession', 'Client Connection to DA lost; Error code:'+e.code);
		}
	});

	//Add a 'close' event handler for the client socket
	clientSocket.on('close', function(had_error) {
		// Emitted once the socket is fully closed.

		// Set this to stop logging
		clientSocketConnected = false;
		// set connected state - we'll tell the instrumentation code in onTcpReset()
		traceConfig.setDAConnected(false);

		// Yes we can't actually log to the DA BUT if we are in debug mode, we will print to the console
		logInfo(logLocation+'.initClientSession', 'Client Connection closed, had error=' + had_error);

		clientSocket.end();
		// Close the client socket completely
		clientSocket.destroy();
		if (traceSocketConnected) {
			traceSocket.end();
		}
		onTcpReset();
	});

	clientSocket.on('end', function() {

		// Set this to stop logging
		clientSocketConnected = false;

		// Found it documented for NodeJS that end() calls destroy()
		// but not sure which version(s) that apply to so let's be safe
		// Close the client socket completely
		clientSocket.destroy();
		// set connected state - we'll tell the instrumentation code in onTcpReset()
		traceConfig.setDAConnected(false);

		// Emitted when the other end of the socket sends a FIN packet.
		// end() calls destroy()
		if (traceSocketConnected) {
			traceSocket.end();
		}
		// Yes we can't actually log to the DA BUT if we are in debug mode, we will print to the console
		logInfo(logLocation+'.initClientSession', 'Client Socket END event; rcvdDataChunks remaining:'+rcvdDataChunks.length);
		onTcpReset();
	});
}

function initTraceSession() {

	logDebug(logLocation+'.initTraceSession', 'create trace socket and connect');
	traceSocket = net.connect(port, host, onTraceConnect);

	// Add a 'data' event handler for the trace socket
	// data is what the server sent to this socket
	traceSocket.on('data', function(data) {
		// we should never receive data (responses or requests) on this socket - log it and move on
		logInfo(logLocation+'.initTraceSession', 'Unexpected data received on trace socket connection');
	});

	//Add an 'error' event handler for the trace socket
	traceSocket.on('error', function(e) {

		// Emitted when an error occurs. The 'close' event will be called directly following this event.

		logError(logLocation+'.initTraceSession', 'Could not connect to DA for trace; Error code:'+e.code);

		// it would be odd to have connected the client socket and not this one
		// but if that's the case, retry anyway
		// Keep retrying until the client socket is closed or this succeeds
		if (clientSocketConnected) {
			traceSocket.destroy();
			setTimeout(function() {
				initTraceSession();
			}, 5000);
			logWarn(logLocation+'.initTraceSession', 'Trace connection refused; will re-attempt to connect.');
		}
	});

	//Add a 'close' event handler for the trace socket
	traceSocket.on('close', function(had_error) {
		// Emitted once the socket is fully closed.

		traceSocket.destroy();
		logInfo(logLocation+'.initTraceSession', 'Trace connection closed, had error=' + had_error);
		if (clientSocketConnected) {
			clientSocket.end();
			// Close the client socket completely
			clientSocket.destroy();
		}
	});

	traceSocket.on('end', function() {
		// Emitted when the other end of the socket sends a FIN packet.
		logInfo(logLocation+'.initTraceSession', 'Trace Socket END event; rcvdDataChunks remaining:'+rcvdDataChunks.length);

		traceSocket.destroy();
		// close clientSocket and let it reset variables and handle reconnects
		if (clientSocketConnected) {
			clientSocket.end();
			// Close the client socket completely
			clientSocket.destroy();
		}
   });
};

function updateConfig() {
	logDebug(logLocation+'.updateConfig', 'UPDATE CONFIG');
	// tell the parent process
	process.send({'type':'instrument','hook':traceConfig.shouldInstrument()});
	process.send({'type':'shortcircuit','isShortCircuit':traceConfig.isShortCircuited()});
	process.send({'type':'sendeueresphdrs','send':traceConfig.isSendEUEResponseHeaders()});
	process.send({'type':'loglevel','level':traceConfig.getLogLevel()});

	// Always send a configuration notify message after updating the configuration.
	configNotify();

	// DEBUG code
	//testEndSession();
	//testCreateTraceProperties();
	//setInterval(testCallTrace, 1000);
	//testSendingSampleData();
	//LogMessage("warn", "Detected DA disconnecting")
	// END DEBUG code
}

function readyToTrace() {
	if (sessionId > 0 && clientSocketConnected && traceSocketConnected) {
		return true;
	} else {
		return false;
	}
}

function persistTraceResults() {
	if(traceQueue.length>0) {

		if (!readyToTrace()) {
			logInfo(logLocation+'.persistTraceResults', 'Flushing trace - DA not connected');
			traceQueue.length = 0;
		}
		while (traceQueue.length > 0) {
			var traceData = traceQueue.shift();

			if ("type" in traceData) {
			    //property exists
				if (traceData.type === 'start') {
					callStart(traceData);
				} else if (traceData.type === 'end') {
					callComplete(traceData);
				}
			}
			// else not our trace - skip
		}
	}
	// check again for batch of results after interval
	setTimeout(persistTraceResults,traceWriteIntervalMs);
}

function persistEnvResults() {
	if(envQueue.length>0) {
		if (!readyToTrace()) {
			logInfo(logLocation+'.persistEnvResults', 'Flushing env metrics - DA not connected');
			envQueue.length = 0;
		}
		while (envQueue.length > 0) {
			var envData = envQueue.shift();
			sendSamples(envData);
		}
	}
	// check again for batch of results after interval
	setTimeout(persistEnvResults,envWriteIntervalMs);
}

function writeMsg(msg, callback) {
	// Do not check readyToTrace() in this method. Some msgs need to be sent
	// before we are ready to trace
	if (sessionId > 0 && clientSocketConnected) {
		if (callback === undefined) {
			callback = function () {};
		}
		clientSocket.write(msg, callback);
	}
}

function writeMetrics(msg, callback) {
	if (readyToTrace()) {
		if (callback === undefined) {
			callback = function () {};
		}
		clientSocket.write(msg, callback);
	}
}

function writeTrace(msg, callback) {
	if (readyToTrace()) {
		if (callback === undefined) {
			callback = function () {};
		}
		traceSocket.write(msg, callback);
	}
}

function beginSession() {
	// max length = 140 = transportHdrLen(8) + msgHdrLen(max 29) + beginSessionLen(max 83 + 20 for hostname)
	var buffer = new Buffer(256);

	// set up msg
	var msg = session.encodeBegin(buffer, moniker, pid, dockerSupport.getLongDockerContainerId(),
								  dockerSupport.getContainerHostname());

	if (clientSocketConnected) {
		clientSocket.write(msg.buffer.slice(0, msg.sndLength),  function () {});
	}
	buffer = null;
}

function endSession() {
	// max length = 41 = transportHdrLen(8) + msgHdrLen(max 29) + endSessionLen(4)
	var buffer = new Buffer(64);

	// set up msg
	var msg = session.encodeEnd(buffer, sessionId);

	writeMsg(msg.buffer.slice(0, msg.sndLength));
	buffer = null;
}

function logMessage(severity, msg) {

	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//NOTE:  if log messages are needed in this method - use console.log (info, etc); Logging from inside
	//any method called (directly or indirectly) as a result of calling logMessage creates the potential
	//for a blown stack (as LogMessage calls LogMessage calls LogMessage.......)

	// don't use allocateBuffer - it logs
	// 14 = 4 bytes message ID + 1 byte string id + 4 bytes severity length + 1 byte sring id + 4 bytes msg length
	var buffer = new Buffer(msgcon.TRANSPORT_HDR_LEN + msgcon.MSG_HDR_LEN_MAX + 14 + severity.length + msgUtil.getStringBytes(msg));

	// set up msg
	var msg = msgConfig.encodeLogMessage(buffer, sessionId, severity, msg);

	if (msg.sndLength !== 0) {
		writeMsg(msg.buffer.slice(0, msg.sndLength));
	}
	buffer = null;
}

function configNotify() {
	var buffer = msgUtil.allocateBuffer(32);

	// set up msg
	var msg = msgConfig.encodeConfigNotify(buffer, sessionId);

	writeMsg(msg.buffer.slice(0, msg.sndLength));
	buffer = null;
}

function callStart(traceData) {
	var buffer = msgUtil.allocateBuffer(512);

	// set up msg
	var msg = trace.encodeCallStartNVP(buffer, sessionId, traceData);

	// DEBUG
	//dumpMessage(msg, "CALL START", traceData);

	writeTrace(msg.buffer.slice(0, msg.sndLength));
	buffer = null;
}

function callComplete(traceData) {
	var buffer = msgUtil.allocateBuffer(512);

	// set up msg
	var msg = trace.encodeCallCompleteNVP(buffer, sessionId, traceData);

	//DEBUG
	//dumpMessage(msg, "CALL COMPLETE", traceData);

	writeTrace(msg.buffer.slice(0, msg.sndLength));
	msg.buffer = null;
}

function createTraceProperties() {

	// if we already established a connection, init the properties now
	if (!initedEnvProps && envProperties !== undefined && sessionId !== -1) {

		initedEnvProps = true;

		var buffer = msgUtil.allocateBuffer(1280);

		// set up msg
		var msg = trace.encodeCreateTraceProperties(buffer, sessionId, envProperties);

		writeMsg(msg.buffer.slice(0, msg.sndLength), function () {
			tracePropsSent = true;
		});
		msg.buffer = null;
	}
}

function createMetricGroup(metricGroup) {

	var buffer = msgUtil.allocateBuffer(740);

	// Send data.
	var msg = metricDefs.createMetricGroup(buffer, sessionId, metricGroup);

	writeMsg(msg.buffer.slice(0, msg.sndLength), function () {
		numMetricGroupsLeft--;
	});
	buffer = null;
}

function createDataClass(metricGroup) {

	var buffer = msgUtil.allocateBuffer(256);

	// Send data.
	var msg = metricDefs.createDataClass(buffer, sessionId,  metricGroup);

	writeMsg(msg.buffer.slice(0, msg.sndLength), function () {
		numMetricGroupsLeft--;
		if (numMetricGroupsLeft === 0) {
			completeSessionInit();
		}
	});
	buffer = null;
}

// Convenience function that calls create hard-coded groups.
function initMetricGroup() {

	var length = metrics.metricGroupNames.length;

	// Initialize all groups of metrics.
	numMetricGroupsLeft = length * 2;
	for (var i = 0; i < length; i++) {

	    createDataClass(metrics.metricGroups[metrics.metricGroupNames[i]]);
	    createMetricGroup(metrics.metricGroups[metrics.metricGroupNames[i]]);
	}
}

function sendSampleData(groupName, samples) {

	var buffer = msgUtil.allocateBuffer(256);

	//set up msg
	var msg = metricData.sendSampleData(buffer, sessionId, groupName, samples);

	writeMetrics(msg.buffer.slice(0, msg.sndLength));
	buffer = null;
}

function sendSamples(sampleData, groupName) {

	var samples = null;

	// Group name sent in.
	if (groupName !== undefined) {

		var group = metrics.metricGroups[groupName];

		// This is a valid group name (predefined in metrics.js).
		if (group !== undefined) {

			samples = group.samples;
		}
	}

	// Iterate through the object looking for groups and data.
	for (var sample in sampleData) {

		var value = sampleData[sample];

		// Found a group, sample is the group name.
		if (value !== null && typeof value === 'object') {

			// Recursive call to print this group.
			sendSamples(sampleData[sample], sample);

	    // Sample data for a group.
		} else {

			// This is a valid sample (predefined in metrics.js).
			if (samples != null && samples[sample] != undefined) {

				samples[sample].value = sampleData[sample];
			}
		}
	}

	// Send the group data.
	if (samples != null) {

		sendSampleData(groupName, samples);
		logDebug(logLocation+'.sendSamples', 'Sending:'+groupName);
	}
}

function onTcpData() {

	while (rcvdDataChunks.length !== 0) {
		logDebug(logLocation+'.onTcpData', 'rcvdDataChunks:'+rcvdDataChunks.length);

		var buffer = rcvdDataChunks[0];
		if (buffer.length >= msgcon.TRANSPORT_HDR_LEN) {
			var transportInfo = transportHdr.decode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN));

			logDebug(logLocation+'.onTcpData', 'expected Length:'+transportInfo.rcvdLength);
			logDebug(logLocation+'.onTcpData', 'received length:'+buffer.length);

			// an invalid transport header can only occur if the buffer length is smaller than
			// the transport  header length. Since we checked above - this can't happen

			// see if got a whole msg in this data chunk
			if (buffer.length === transportInfo.rcvdLength) {
				logDebug(logLocation+'.onTcpData', 'Processing data chunk containing one msg');
				// we got a complete msg in this chunk - process it
				processReceivedData(rcvdDataChunks.shift(), transportInfo);

			} else if (buffer.length < transportInfo.rcvdLength) {
				logDebug(logLocation+'.onTcpData', 'Processing msg spanning multiple data chunks');
				// we got less than a full msg - do we have another in the queue?
				if (rcvdDataChunks.length > 1) {
					logDebug(logLocation+'.onTcpData', 'Concat data chunks and check for complete msg');
					// we have multiple - concat them
					var buf1 = rcvdDataChunks.shift();
					var buf2 = rcvdDataChunks.shift();
					var buf3 = Buffer.concat([buf1, buf2], (buf1.length+buf2.length));
					rcvdDataChunks.unshift(buf3);
					// we will handle in the next loop
				} else {
					// wait for next chunk
					break;
				}
			} else {
				logDebug(logLocation+'.onTcpData', 'Processing multiple msgs received in one chunk');
				// we have extra stuff - pull off what we need for this msg
				buffer = rcvdDataChunks.shift();
				var buf1 = new Buffer(transportInfo.rcvdLength);
				buffer.copy(buf1, 0 , 0 , transportInfo.rcvdLength);
				var buf2 = new Buffer(buffer.length - transportInfo.rcvdLength);
				buffer.copy(buf2, 0 , transportInfo.rcvdLength, buffer.length);

				// put the second data chunk back (it may be incomplete or be multiple msgs_
				rcvdDataChunks.unshift(buf2);
				// process the first msg
				processReceivedData(buf1, transportInfo);
			}
		} else {
			// buffer is smaller than a transport header
			// do we have another in the queue?
			// If so, concatenate with next and try again
			if (rcvdDataChunks.length > 1) {
				logDebug(logLocation+'.onTcpData', 'Incomplete transport hdr - concat data chunks and check for complete msg');
				// we have multiple - concat them
				var buf1 = rcvdDataChunks.shift();
				var buf2 = rcvdDataChunks.shift();
				var buf3 = Buffer.concat([buf1, buf2], (buf1.length+buf2.length));
				rcvdDataChunks.unshift(buf3);
				// we will handle in the next loop
			} else {
				// wait for next chunk
				break;
			}
		}
	}
}

function processReceivedData(buffer, transportInfo) {

	// Message Header processing
	var msgHeaderInfo = msgHeader.decode(buffer.slice(msgcon.TRANSPORT_HDR_LEN));

	// message header validity checking
	if (msgHeaderInfo.valid === false) {
		// can't really continue - something bad happened
		// throw this message away
		logError(logLocation+'.processReceivedData', 'data from DA cannot be processed; bufLen:'+buffer.length);
		return;
	}

	if (msgHeaderInfo.gotRequest) {
		logDebug(logLocation+'.processReceivedData', 'REQUEST');
		processRequest(buffer.slice(msgcon.TRANSPORT_HDR_LEN+msgHeaderInfo.hdrLength), transportInfo);
	} else {
		logDebug(logLocation+'.processReceivedData', 'RESPONSE');
		// response - make sure endian passed back is the same as we requested
		if (transportInfo.encoding !== msgUtil.endianness) {
			transportHdr.valid = false;
			logError(logLocation+'.processReceivedData', 'response msg is encoded incorrectly');
			// throw this message away
			return;
		}
		// TODO - transport header validity checking (char encoding)

		processResponse(buffer.slice(msgcon.TRANSPORT_HDR_LEN+msgHeaderInfo.hdrLength));
	}
}

function processRequest(request, transportInfo) {

	if (sessionId === -1) {
		// receiving data from the DA before we have a valid sessionId
		// It might be recoverable by resetting the config settings, restarting the DA, ????
		// so don't close the connections and restart
		logError(logLocation+'.processRequest', 'ignoring a request made before a valid session id was received');
		return;
	}

	// get the msg opcode
	var opcode = msgUtil.readInteger(request, 0, 4, transportInfo.encoding);

	switch(opcode) {
		case msgcon.Opcode.ConfigChange:
			if (sessionId === -1) {
				// something went wrong  - we are being sent a CONFIG CHANGE before we get a valid session id
				// the DA is misbehaving - ignore the request
				logError(logLocation+'.processRequest', 'Ignoring CONFIG CHANGE received; sessionId is invalid');
			} else {
				logInfo(logLocation+'.processRequest', 'Received a config change request');
				msgConfig.decodeConfigChange(request, transportInfo);
				if (traceConfig.isShortCircuited()) {
					// update instr code config and send ConfigNotify
					updateConfig();
				} else if (!traceSocketConnected) {
					// This is the first ConfigChnage after a session has been started
					// We'll take care up calling updateConfigChange() after we create a trace socket
					initTraceSession();
				} else {
					// we are NOT short-circuited and already have a trace conenction
					updateConfig();
				}
			}
			break;
		default:
			logWarn(logLocation+'.processRequest', 'Received an unsupported request:'+opcode);
	}
}

function processResponse(response) {

	//TODO process msgId to determine this is a response to BeginSession
	// for now it is the only one we get

	var statusCode = msgUtil.readInteger(response, 0, 4);
	var errMsg = '';

	if (statusCode === 0) {
		sessionId = msgUtil.readInteger(response, 4, 4);
	} else {
		//TODO TEST THIS - msgRsponse.length may not work - may have something following
		errMsg = response.toString('utf8',4,response.length);
		// Since we don't have a session this will go to the console
		logError(logLocation+'.processResponse', 'Error receiving session ID:'+statusCode+':'+errMsg);
		// try again to get a session
		beginSession();
		return;
	}

	logInfo(logLocation+'.processResponse', 'sessionId:'+sessionId);

	//Instrumentation code uses this to know when to log - okay to set it now
	traceConfig.setDAConnected(true);
	process.send({'type':'daConnectState','connected':traceConfig.isDAConnected()});

	// we can send initialization data to the NodeDA now
	// even if the instr is bypassed, instr will not start until a
	// ConfigChange is received

	// Synchronous stuff
	persistTraceResults();
	persistEnvResults();

	// Asynchronous stuff - we need to track when this is done
	// Initialize for tracing
	createTraceProperties();
	// Initialize the predefined metrics.
	initMetricGroup();
}

//-----------------------------
//External Functions
//-----------------------------

var init = exports.init = function (options,monikerArg, pidArg) {

	host = (options && options.dataHost) ? options.dataHost : DEFAULT_HOST;
	port = (options && options.dataPort) ? options.dataPort : DEFAULT_PORT;
	moniker = monikerArg;
	pid = pidArg;

	// Figure out if we're in a docker container
	// If so, enable docker support
	dockerSupport.init(options);

	initClientSession();

	// remaining init tasks will be completed when the sessionId is returned
};

//called when parent process is exiting
var cleanup = exports.cleanup = function () {
	if (clientSocketConnected) {
		//end session
		if (sessionId !== -1) {
			endSession();
		}
		// kill client
		clientSocketConnected = false;
		if (clientSocket !== -1) {
			clientSocket.destroy();
		}
	}
	if (traceSocketConnected) {
		// kill trace
		traceSocketConnected = false;
		if (traceSocket !== -1) {
			traceSocket.destroy();
		}
	}
};

var setEnvProps = exports.setEnvProps = function(envProps) {
	// save in case we are disconnected
	envProperties = envProps;
	createTraceProperties();
};


//push the result onto the queue now to get persisted at some point
var addTraceResult = exports.addTraceResult = function(tracingData) {
	traceQueue.push(tracingData);
};

var addEnvResult = exports.addEnvResult = function(envData) {
	envQueue.push(envData);
};

var persistProfileResult = exports.persistProfileResult = function(profilesPath,profileId,profile) {
//	var profileFile = path.join(profilesPath,profileId+profileFileExtension);
//	fs.writeFile(profileFile,JSON.stringify(profile),function(err){
//		if(err) {
//		    logError(logLocation+'.persistProfileResult', 'failed to write profile file:'+profileFile);
//		} else {
//    		logInfo(logLocation+'.persistProfileResult', 'wrote profile file:'+profileFile);
//		}
//		// delete profile now
//		profile.delete();
//	});
};

var persistSnapshotResult = exports.persistSnapshotResult = function(snapshotsPath,snapshotId,snapshot) {
//	var snapshotFile = path.join(snapshotsPath,snapshotId+snapshotFileExtension);
//	logInfo(logLocation+'.persistSnapshotResult', 'writing heap snapshot to file:'+snapshotFile);
//	var snapshotStream = fs.createWriteStream(snapshotFile);
//	snapshotStream.on("open",function(){
//		snapshot.serialize(
//			function iterator(data, length) {
//				snapshotStream.write(data);
//			},
//			function callback() {
//		  		snapshotStream.end();
//		  		// delete snapshot now
//		  		snapshot.delete();
//				logDebug(logLocation+'.persistSnapshotResult', 'wrote heap snapshot to file'+snapshotFile);
//			}
//		);
//	});
};

var setDebugMode = exports.setDebugMode = function(debugMode) {
	traceConfig.setDebugMode(debugMode);
};

var logOverTCP = exports.logOverTCP = function(logLevel,msg) {
	logMessage(traceConfig.LOGGING_LEVEL_STRS[logLevel], msg, true);
};

var logDebug = exports.logDebug = function(location,msg) {
	// is logging level fine enough that we should record this?
	if(traceConfig.shouldLogToDa(traceConfig.LOGGING_LEVELS.DEBUG,location,msg)) {
		// send message downstream for logging over TCP
		logOverTCP(traceConfig.LOGGING_LEVELS.DEBUG, location+" - "+msg)
	}
};

var logInfo = exports.logInfo = function(location,msg) {
	// is logging level fine enough that we should record this?
	if(traceConfig.shouldLogToDa(traceConfig.LOGGING_LEVELS.INFO,location,msg)) {
		// send message downstream for logging over TCP
		logOverTCP(traceConfig.LOGGING_LEVELS.INFO, location+" - "+msg)
	}
};

var logWarn = exports.logWarn = function(location,msg) {
	// is logging level fine enough that we should record this?
	if(traceConfig.shouldLogToDa(traceConfig.LOGGING_LEVELS.WARN,location,msg)) {
		// send message downstream for logging over TCP
		logOverTCP(traceConfig.LOGGING_LEVELS.WARN, location+" - "+msg)
	}
};

var logError = exports.logError = function(location,msg) {
	// is logging level fine enough that we should record this?
	if(traceConfig.shouldLogToDa(traceConfig.LOGGING_LEVELS.ERROR,location,msg)) {
		// send message downstream for logging over TCP
		logOverTCP(traceConfig.LOGGING_LEVELS.ERROR, location+" - "+msg)
	}
};

//-----------------------------
// DEBUG/Test Functions
//-----------------------------

//test code for TCP Test Server (do not use this for NodeDA)
function testEndSession() {
	endSession();
}

// test code for TCP Test Server (do not use this for NodeDA)
function testCreateTraceProperties(){
	createTraceProperties();
}

//test code for TCP Test Server (do not use this for NodeDA)
function testCallTrace(){
	var traceData = {txId:101, category:'generic', file:'http', method:'tier1Callback', time:Date.now(),
			props: [{name:'async.id', 'value':1234}, {name:'property2', value:'value1'}, {name:'property2',value:'value2'}]
	};
	//props, no exception property
	callStart(traceData);
	callComplete(traceData);
	// empty props, no exception property
	traceData = {txId:101, category:'generic', file:'http', method:'tier1Callback', time:Date.now(), props: [] };
	callStart(traceData);
	callComplete(traceData);
	// no  props property, no exception property
	traceData = {txId:101, category:'generic', file:'http', method:'tier1Callback', time:Date.now() };
	callStart(traceData);
	callComplete(traceData);
	// empty exceptions
	traceData = {txId:101, category:'generic', file:'http', method:'tier1Callback', time:Date.now(), props: [], exceptions:[] };
	callStart(traceData);
	callComplete(traceData);
	// exceptions - just one
	traceData = {txId:101, category:'generic', file:'http', method:'tier1Callback', time:Date.now(), props: [], exceptions:["NullPointer"] };
	callStart(traceData);
	callComplete(traceData);
	// exceptions - multiple
	traceData = {txId:101, category:'generic', file:'http', method:'tier1Callback', time:Date.now(), props: [], exceptions:["SomeException", "IndexOutOfBounds", "Runtime"] };
	callStart(traceData);
	callComplete(traceData);
}

function dumpMessage(msg, functionLabel, data) {
	var sndBuffer = msg.buffer.slice(0, msg.sndLength);
	console.log (logLocation+'.dumpMessage'+' - '+'sndBuffer length:'+sndBuffer.length);
//	for (var index = 0; index < sndBuffer.length; index++) {
//		console.log (logLocation+'dumpMessage'+' - '+sndBuffer[index].toString(16));
//	}
	console.log (logLocation+'.dumpMessage'+' - '+functionLabel);
	console.log (logLocation+'.dumpMessage'+' - '+'data:'+JSON.stringify(data));
}

// Test code for sending metric data.
function testSendingSampleData() {

	// Send data for 30 seconds.
	for (var i = 0; i < 30; i++) {

		var result = {
				'moniker': "moniker",
				'pid':1234,
				'endTime': Date.now(),
				'timespanSec': 3434,
				'eventLoop':444 + i,
				'memoryUsage':555 + i,
		        'Memory Management': {
		        	'MBs in use':555 + i
		        }
			};
			result.httpRequests = {
				'inbound':{
					'loadPerSec':7777,
					'concurrent':88888
				},
				'outbound':{
					'loadPerSec':1111,
					'concurrent':22222
				}
			};
			result.fs = {
				'bytesReadPerSec':33333 + i,
				'bytesWrittenPerSec':44444 + i
			};
			sendSamples({'System':result});

		//var samples = metrics.metricGroups["Memory"].samples; // Get the group of metrics
		//samples["AvailableBytes"].value = 99 + i; // Set values
		//samples["CommittedBytes"].value = 88 + i; // Set values
		//sendSampleData("Memory", samples); // Send data
		//console.log(logLocation+'.testSendingSampleData'+' - '+'sending data:'+samples["AvailableBytes"].value + " " + samples["CommittedBytes"].value);
	    var now = new Date().getTime();
		while(new Date().getTime() < now + 1000){ }
	}
}


function debugKill() {
	var randomNum = Math.floor(Math.random() * 99); // get a random index from 0
													// to 99
	console.log("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  random # = " + randomNum);
	if (randomNum > 90) {
		process.exit();
	}
	setTimeout(debugKill, 3000);
}
