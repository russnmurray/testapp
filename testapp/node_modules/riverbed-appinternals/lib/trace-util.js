/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// Utilities Module
// *****************************

var path = require('path'),
	util = require('util'),
	Buffer = require('buffer').Buffer;

var findCallbackArgumentIndex = exports.findCallbackArgumentIndex = function (argArray) {
	if(!argArray) {
		return -1;
	}

	// First, make sure the arguments are an actual array and duplicate that array.
	var args = Array.prototype.slice.call(argArray);
	
	if(!args || args.length < 1) {
		return -1;
	}

	// pop off the final arg
	var current = args.pop();

	if(current instanceof Function) {
		// last argument was a function. 
		// we already popped off the last arg
		// so the current length is it's index
		return args.length;
	}

	if(typeof(current)==='undefined') {
		// recursive call if this arg is undefined
		return findCallbackArgumentIndex(args);
	}

	// the last arg is something other than a function, and we haven't found a function yet.
	return -1;
};

var getHrTimeMs = exports.getHrTimeMs = function() {
	var time = process.hrtime();
	return (1000*time[0] + 1.0e-6*time[1]);
}

var getFunctionName = exports.getFunctionName = function(userHandler) {
	var funcName = userHandler.name;
	if (userHandler.name == 'g' && userHandler.listener && userHandler.listener instanceof Function) {
		// grab the name of the listener rather than using 'g'
		// don't want to include && handler.listener.name in the if condition
		// because we don't want to use 'g' even if the listener is an anonymous function
        funcName = userHandler.listener.name;
    }
    return funcName;
};

var safePushExceptionsStack = exports.safePushExceptionsStack = function(tracingData,val) {
	if(tracingData) {
		if(!util.isArray(tracingData.exceptionsStack)) {
			tracingData.exceptionsStack = [];
		}
		tracingData.exceptionsStack.push(val);
	}
};

var safePopExceptionsStack = exports.safePopExceptionsStack = function(tracingData) {
	if(tracingData && util.isArray(tracingData.exceptionsStack)) {
		return tracingData.exceptionsStack.pop();
	}
};

var safeAddExceptionToExceptionsStack = exports.safeAddExceptionToExceptionsStack = function(tracingData,val) {
	if(tracingData && util.isArray(tracingData.exceptionsStack) && tracingData.exceptionsStack.length>0) {
		var currentStack = tracingData.exceptionsStack[tracingData.exceptionsStack.length-1];
		if(util.isArray(currentStack)) {
			currentStack.push(val);
		}
	}
};

// *********************************************************
// polyfill of path.parse, which only exists in 0.12.x and greater
// based on the Node 4.2.1 code 
// *********************************************************

function assertPath(pathString) {
	if (typeof pathString !== 'string') {
		throw new TypeError('Path must be a string. Received ' + util.inspect(pathString));
	}
};

// Function to split a filename into [root, dir, basename, ext]
function win32SplitPath(filename) {
	// Separate device+slash from tail
		// Regex to split a windows path into three parts: [*, device, slash,
		// tail] windows-only
	var result = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/.exec(filename),
	    device = (result[1] || '') + (result[2] || ''),
	    tail = result[3];
	// Split the tail into dir, basename and extension
		// Regex to split the tail part of the above into [*, dir, basename, ext]
	var result2 = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/.exec(tail),
	    dir = result2[1],
	    basename = result2[2],
	    ext = result2[3];
	return [device, dir, basename, ext];
}

function posixSplitPath(filename) {
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var out = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(filename);
	out.shift();
	return out;
}

var pathParsePolyfillWin32 = function(pathString) {
	assertPath(pathString);
	var allParts = win32SplitPath(pathString);
	return {
		root: allParts[0],
		dir: allParts[0] + allParts[1].slice(0, -1),
		base: allParts[2],
		ext: allParts[3],
		name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
	};
};

var pathParsePolyfillPosix = function(pathString) {
	assertPath(pathString);
	var allParts = posixSplitPath(pathString);
	return {
		root: allParts[0],
		dir: allParts[0] + allParts[1].slice(0, -1),
		base: allParts[2],
		ext: allParts[3],
		name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
	};
};

var pathParse = exports.pathParse = function(pathString) {
	if(path.parse) {
		return path.parse(pathString);
	} else {
		if(process.platform === 'win32') {
			return pathParsePolyfillWin32(pathString);
		} else {
			return pathParsePolyfillPosix(pathString);
		}
	}
};


// *********************************************************
// polyfill of util.isString, which only exists in 0.12.x and greater
// based on the Node 4.2.1 code 
// *********************************************************

var isString = exports.isString = function(arg) {
	if(util.isString) return util.isString(arg);
	return typeof arg === 'string';
};

// *********************************************************
// polyfill of util.isNumber, which only exists in 0.12.x and greater
// based on the Node 4.2.1 code 
// *********************************************************

var isNumber = exports.isNumber = function(arg) {
	if(util.isNumber) return util.isNumber(arg);
	return typeof arg === 'number';
};

// *********************************************************
// polyfill of util.isBuffer, which only exists in 0.12.x and greater
// based on the Node 4.2.1 code 
// *********************************************************

var isBuffer = exports.isBuffer = function(arg) {
	if(util.isBuffer) return util.isBuffer(arg);
	return Buffer.isBuffer(arg);
};
