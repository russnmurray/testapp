/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

var	traceOutApi = require('./trace-output-api');

// *****************************
// Mongo Instrumentation Module
// *****************************

// required modules
var hooker = require('hooker'),
	uuid = require('uuid'),
	path = require('path'),
	traceUtil = require('./trace-util'),
	traceOutput = require('./trace-output-api'),
	traceCLS = require('./trace-cls'),
	traceConfig = require('./trace-config'),
	traceEvent = require('./trace-event'),
	EventEmitter = require('events').EventEmitter;

// -----------------------------
// Internal Functions
// -----------------------------

function clsBindCallbackArg(theModule, moduleName, theFunction, bindResult) {
	hooker.unhook(theModule, theFunction);
    hooker.hook(theModule, theFunction,

        {
            'passName': false,

            'pre': function mongoWrapCallbackArg() {

                // grab the original function
                var origFunc = hooker.orig(theModule,theFunction);

                // First, make sure the arguments are an actual array.
                var args = Array.prototype.slice.call(arguments);

	            // Are we short-circuited at this point
	            var shortCircuited = traceConfig.isShortCircuited();

	            // only collect data if not short-circuited
	            if(!shortCircuited) {

	                var callbackIdx = traceUtil.findCallbackArgumentIndex(args),
                    	callbackProvided = (callbackIdx >= 0);

	                if(callbackProvided) {
	                	// bind the callback arg
		            	args[callbackIdx]=traceCLS.bind(args[callbackIdx]);
		            	traceOutput.debug(moduleName+"."+theFunction,"CLS bound callback argument");
	            	}

	            	if(this instanceof EventEmitter) {
	            		traceCLS.bindEmitter(this);
	            		traceOutput.debug(moduleName+"."+theFunction,"bound EventEmitter");
	            	}
	            }

                var result = origFunc.apply(this,args);

                if(!shortCircuited && bindResult) {
                	// bind the wrapped result
                	result=traceCLS.bind(result);
                	traceOutput.debug(moduleName+"."+theFunction,"CLS bound return value");
                }

                // return while telling 'hooker' not to call the function itself ('preempt'),
                // because we already just did.
                return hooker.preempt(result);
            }
        }
    );
};

function clsBindMongoEmitters(theModule, moduleName, theFunction) {
	hooker.unhook(theModule.prototype, theFunction);
    hooker.hook(theModule.prototype, theFunction,
    {
            'passName': false,

            'pre' : function bind() {
            	if(this instanceof EventEmitter) {
            		traceCLS.bindEmitter(this);
            		traceOutput.debug(moduleName,"bound EventEmitter");
            	}
            },

            'post': function bind() {
            	if(this instanceof EventEmitter) {
            		traceCLS.bindEmitter(this);
            		traceOutput.debug(moduleName,"bound EventEmitter");
            	}

            	if(this.connection && this.connection instanceof EventEmitter) {
            		traceCLS.bindEmitter(this.connection);
            		traceOutput.debug(moduleName,"bound connection as EventEmitter");
            	}

            	if (this.connectionPool) {
					traceCLS.bindEmitter(this.connectionPool);
					traceOutput.debug(moduleName,"bound connectionPool as EventEmitter");
				}

				if(this._callBackStore) {
					traceCLS.bindEmitter(this._callBackStore);
					traceOutput.debug(moduleName,"bound CallbackStore as EventEmitter");
				}

            	if(arguments && arguments.length>0 && arguments[0] instanceof EventEmitter) {
            		traceCLS.bindEmitter(arguments[0]);
            		traceOutput.debug(moduleName+".prototype."+theFunction,"bound EventEmitter");
            	}
            }
        }
	);
};

function clsBindWithCallback(theModule,moduleName,theFunction) {
	// Unhook in case already hooked
    hooker.unhook(theModule, theFunction);
    hooker.hook(theModule, theFunction,

        {
            'passName': false,

            'pre': function mongoWrapper() {

                // grab the original function
                var origFunc = hooker.orig(theModule,theFunction);

                // First, make sure the arguments are an actual array.
                var args = Array.prototype.slice.call(arguments);

                var shortCircuited = traceConfig.isShortCircuited();

                var callbackIdx = traceUtil.findCallbackArgumentIndex(args),
                	callbackProvided = (callbackIdx >= 0);

                // was a callback specified as part of args?
                if(!shortCircuited && callbackProvided) {

                    // If so, need to wrap it and replace it w/ our wrapped version in args
                    // when calling original function
                    traceOutput.debug(moduleName+'.'+theFunction,"wrapping user's callback");
                    var userCallback = traceCLS.bind(args[callbackIdx]);

                    var wrappedCallback = function () {
                        // First, make sure the arguments are an actual array.
                        var args = Array.prototype.slice.call(arguments);

                        if(args.length>1 && args[1] instanceof EventEmitter) {
                        	traceCLS.bindEmitter(args[1]);
                        	traceOutput.debug(moduleName+'.'+theFunction,"bound argument to user's callback as EventEmitter");
                        }

				        // call the actual handler (the user's handler).
				         // return handler.apply(this, args);
				        // ORIG
				        return userCallback.apply(this, args);
                    };
	            	args[callbackIdx]=traceCLS.bind(wrappedCallback);
	            }

                var result = origFunc.apply(this,args);

 	            if(!shortCircuited) {
	            	if(result && result instanceof EventEmitter) {
	                	traceCLS.bindEmitter(result);
	                	traceOutput.debug(moduleName+'.'+theFunction,"bound result as EventEmitter");
	            	}
	            }
                // return while telling 'hooker' not to call the action itself ('preempt'),
                // because we already just did.
                return hooker.preempt(result);
            }
        }
    );
};

function hookAction(theModule, moduleName, theFunction) {

    // Unhook in case already hooked
    hooker.unhook(theModule, theFunction);
    hooker.hook(theModule, theFunction,

        {
            'passName': false,

            'pre': function mongoWrapper() {

                // grab the original function
                var origFunc = hooker.orig(theModule,theFunction);

                // First, make sure the arguments are an actual array.
                var args = Array.prototype.slice.call(arguments);

	            // Are we short-circuited at this point
	            // NOTE: if we are not short-circuited at the time the query is created, we will completely finish handling it,
				// even if we are short-circuited mid-way through the request.
	            var shortCircuited = traceConfig.isShortCircuited();

	            // only collect data if not short-circuited
	            if(!shortCircuited) {

	            	// outbound request txn id, assuming we're in a CLS context, this will get set using the current counter below
	            	var reqID = 0;

	                var callbackIdx = traceUtil.findCallbackArgumentIndex(args),
                    	callbackProvided = (callbackIdx >= 0),
                    	sql = "";
	                if(args.length>0) {
	                	sql = theFunction+" "+JSON.stringify(args[0]);
	                } else if(this.cmd) {
	                	sql = JSON.stringify(this.cmd);
	                }

	            	traceCLS.ifDataDo(moduleName+'.'+theFunction,function(tracingData){
			        	// use the current iterator value as the request id and increment the iterator
	            		reqID = tracingData.nextAsyncId;
		            	tracingData.nextAsyncId++;

		                // was a callback specified as part of args?
		                if(callbackProvided) {

		                    // If so, need to wrap it and replace it w/ our wrapped version in args
		                    // when calling original function
		                    traceOutput.debug(moduleName+'.'+theFunction,"wrapping user's callback");
		                    var userCallback = traceCLS.bind(args[callbackIdx]);

		                    var wrappedCallback = function () {
		                        // First, make sure the arguments are an actual array.
		                        var args = Array.prototype.slice.call(arguments);

		                        if(args.length>0 && args[0] instanceof EventEmitter) {
		                        	traceCLS.bindEmitter(args[0]);
		                        	traceOutput.debug(moduleName+'.'+theFunction,"bound argument to user's callback as EventEmitter");
		                        }

		                        if(tracingData && !tracingData.finished) {
			                        traceOutApi.addTraceResult({
							        	'type' 		: 'start',
							        	'txId' 		: tracingData.txId,
							        	'category'	: 'Generic',
							        	'file'		: '',
							        	'method'	: (userCallback.name?userCallback.name:"(anonymous)"),
							        	'time'		: Date.now(),
							        	'props' 	: [
							        		{
					            				'name'		: 'async.id',
					            				'value'		: reqID
					            			},
					           				{
					           					'name'		: 'eventtype',
					           					'value'		: 'response'
					           				}
							        	]
							        });
							        // increment open call count
		        					tracingData.callDepth++;
							        // add an array to track exceptions for this call
									traceUtil.safePushExceptionsStack(tracingData,[]);
								}

						        // call the actual handler (the user's handler).
						         // return handler.apply(this, args);
						        // ORIG
						        var cbResult = userCallback.apply(this, args);

						        if(tracingData && !tracingData.finished) {
							        traceOutApi.addTraceResult({
							        	'type' 			: 'end',
							        	'txId' 			: tracingData.txId,
							        	'time'			: Date.now(),
							        	'props' 		: [],
							        	'exceptions' 	: traceUtil.safePopExceptionsStack(tracingData)
							        });
							        // decrement open call count
		        					tracingData.callDepth--;
							    }

		                      	return cbResult;
		                    };
			            	args[callbackIdx]=traceCLS.bind(wrappedCallback);
		            	}

		            	if(tracingData && !tracingData.finished) {
				            traceOutApi.addTraceResult({
						        	'type' 		: 'start',
						        	'txId' 		: tracingData.txId,
						        	'category'	: 'MongoDB',
						        	'file'		: moduleName,
						        	'method'	: theFunction,
						        	'time'		: Date.now(),
						        	'props' 	: [
						        		{
				            				'name'		: 'async.id',
				            				'value'		: reqID
				            			},
				            			{
				            				'name'		: 'async.category',
				            				'value'		: 'MongoDB'
				            			},
				            			{
				            				'name'		: 'sql',
				            				'value'		: sql
				            			}
						        	]
						        });
			            	// increment open call count
		        			tracingData.callDepth++;
					        // add an array to track exceptions for this call
							traceUtil.safePushExceptionsStack(tracingData,[]);
						}
	            	});
	            }

                var result = origFunc.apply(this,args);

                // take a timestamp
		        var afterCreateReqTimestamp = Date.now();

	        	// only collect data if not short-circuited
	            if(!shortCircuited) {
	            	if(result) {
	            		result._rvbdAsyncId = reqID;
	            		if(result instanceof EventEmitter) {
		                	traceCLS.bindEmitter(result);
		                	traceOutput.debug(moduleName+'.'+theFunction,"bound result as EventEmitter");
		                }
	            	}

	                traceCLS.ifDataDo(moduleName+'.'+theFunction,function(tracingData){
	                	if(tracingData && !tracingData.finished) {
					        traceOutApi.addTraceResult({
					        	'type' 			: 'end',
					        	'txId' 			: tracingData.txId,
					        	'time'			: afterCreateReqTimestamp,
					        	'props' 		: [],
					        	'exceptions' 	: traceUtil.safePopExceptionsStack(tracingData)
					        });
					        // decrement open call count
		        			tracingData.callDepth--;

		            		traceOutput.debug(moduleName+'.'+theFunction,"updated trace with new query: "+reqID);
		            	}
	    			});
	            }
                // return while telling 'hooker' not to call the action itself ('preempt'),
                // because we already just did.
                return hooker.preempt(result);
            }
        }
    );
};

// -----------------------------
// External Functions
// -----------------------------
var instrumentMongo = exports.instrumentMongo = function(requiredMod) {
	var mongo = require(requiredMod),
		isMongo1x = traceUtil.isString(mongo.version) && (mongo.version.indexOf("1.")==0);

	if(isMongo1x) {
		traceOutput.info("mongodb.instrumentMongo","detected mongodb 1.x");
		// This is legacy mongodb 1.x
		try {
			var connection = require(requiredMod+path.sep+'connection'+path.sep+'connection').Connection,
				db = require(requiredMod+path.sep+'db').Db,
				server = require(requiredMod+path.sep+'connection'+path.sep+'server').Server,
				mongos = require(requiredMod+path.sep+'connection'+path.sep+'mongos').Mongos,
				replset = require(requiredMod+path.sep+'connection'+path.sep+'repl_set'+path.sep+'repl_set').ReplSet,
				collection = require(requiredMod+path.sep+'collection').Collection;

			clsBindWithCallback(db.prototype,"mongodb.lib.db.prototype","open");

			clsBindMongoEmitters(connection,"mongodb.lib.mongodb.connection.connection.prototype.start","start");
			clsBindMongoEmitters(server,"mongodb.lib.mongodb.connection.server.prototype.connect","connect");
			clsBindMongoEmitters(mongos,"mongodb.lib.mongodb.connection.server.prototype.connect","connect");
			clsBindMongoEmitters(replset,"mongodb.lib.mongodb.connection.server.prototype.connect","connect");

			[
				"findAndModify","findAndRemove","findOne","find",
			 	"insert","remove","rename","save","update","distinct","count","drop",
			 	"createIndex","ensureIndex","indexInformation","dropIndex","dropAllIndexes","dropIndexes",
			 	"reIndex","mapReduce","group","options","isCapped","indexExists",
			 	"geoNear","geoHaystackSearch","indexes","aggregate","stats",
			 	"initializeUnorderedBulkOp","initializeOrderedBulkOp","parallelCollectionScan"
			].forEach(function(action){
				hookAction(collection.prototype,"mongodb.lib.mongodb.collection.prototype",action);
			});


		} catch (err) {
			traceOutput.error("mongodb.instrumentMongo","error requiring submodules for mongodb 1.x. "+err);
		}
	} else {
		try {
			// This is current mongodb 2.x which utilitizes mongodb-core
			traceOutput.info("mongodb.instrumentMongo","detected mongodb >= 2.x");

			["open","collection"].forEach(function(func){
				clsBindWithCallback(mongo.Db.prototype,"mongodb.lib.db.prototype",func);
			});

			clsBindWithCallback(mongo.MongoClient,"mongodb.MongoClient","connect");

			clsBindMongoEmitters(mongo.Server,"mongodb.lib.server","connect");
			clsBindMongoEmitters(mongo.Mongos,"mongodb.lib.mongos","connect");
			clsBindMongoEmitters(mongo.ReplSet,"mongodb.lib.replset","connect");

			clsBindMongoEmitters(mongo.Server,"mongodb.lib.server","cursor");
			clsBindMongoEmitters(mongo.Mongos,"mongodb.lib.mongos","cursor");
			clsBindMongoEmitters(mongo.ReplSet,"mongodb.lib.replset","cursor");

			// TODO equivalent of connection?

			[
				"find","insertOne","insertMany","bulkWrite","insert","updateOne","replaceOne",
				"updateMany","update","deleteOne","deleteMany","removeMany","remove","save",
				"findOne","rename","drop","options","isCapped","createIndex","createIndexes",
				"dropIndex","dropIndexes","dropAllIndexes","reIndex","listIndexes","ensureIndex",
				"indexExists","indexInformation","count","distinct","indexes","stats","findOneAndDelete",
				"findOneAndReplace","findOneAndUpdate","findAndModify","findAndRemove","aggregate",
				"parallelCollectionScan","geoNear","geoHaystackSearch","group","mapReduce",
				"initializeUnorderedBulkOp","initializeOrderedBulkOp"
			].forEach(function(action){
				hookAction(mongo.Collection.prototype,"mongodb.lib.collection",action);
			});
		} catch (err) {
			traceOutput.error("mongodb.instrumentMongo","error requiring submodules for mongodb 2.x. "+err);
		}
	}
};

var instrumentCoreMongo = exports.instrumentCoreMongo = function(requiredMod) {

	try {

		var mongoCore = require(requiredMod);

		var connection = require(requiredMod+path.sep+'lib'+path.sep+'connection'+path.sep+'connection'),
			pool = require(requiredMod+path.sep+'lib'+path.sep+'connection'+path.sep+'pool');

			clsBindMongoEmitters(connection,"mongodb-core.lib.connection.connection","connect");
			clsBindMongoEmitters(pool,"mongodb-core.lib.connection.pool","connect");

			clsBindMongoEmitters(mongoCore.Server,"mongodb-core.lib.topologies.server","connect");
			clsBindMongoEmitters(mongoCore.Mongos,"mongodb-core.lib.topologies.mongos","connect");
			clsBindMongoEmitters(mongoCore.ReplSet,"mongodb-core.lib.topologies.replset","connect");

			clsBindMongoEmitters(mongoCore.Server,"mongodb-core.lib.topologies.server","cursor");
			clsBindMongoEmitters(mongoCore.Mongos,"mongodb-core.lib.topologies.mongos","cursor");
			clsBindMongoEmitters(mongoCore.ReplSet,"mongodb-core.lib.topologies.replset","cursor");

			// acoble - 26 October 2017 - Bug 290227
			// mongodb module < 2.2.x uses mongodb-core 1.X
			// mongodb  module >= 2.2.x uses mongodb-core 2.X
			// mongodb-core 2.X no longer has lib/topologies/session
			// 		there are a bunch of different auth methods now.
			//		fortunately for us, the auth session is no longer tied to a "cursor" function,
			// 		so we don't have to worry abou this.
			//		if we can't find lib/topologies/session, simply ignore it and move on.
			try {
				var session = require(requiredMod+path.sep+'lib'+path.sep+'topologies'+path.sep+'session');
				hookAction(session.prototype,"mongodb-core.lib.topologies.session","cursor");
			} catch (sessionErr) {
				traceOutput.debug("mongodb.instrumentMongoCore","couldn't include lib/topologies/session. probably harmless and simply means mongodb 2.2.x+ / mongodb-core 2.x+ : "+sessionErr);
			}

			["_find","_getmore","_killcursor","next","kill","rewind"].forEach(function(func){
				hookAction(mongoCore.Cursor.prototype,"mongodb-core.lib.cursor",func);
			});

	} catch (err) {
		traceOutput.error("mongodb.instrumentMongoCore","error requiring submodules for mongodb-core. "+err);
	}
};

var instrumentMongoose = exports.instrumentMongoose = function(requiredMod) {

	try {

		var mongoose = require(requiredMod);

			clsBindMongoEmitters(mongoose.Mongoose.prototype.Connection,"mongoose.lib.connection","_open");
			clsBindMongoEmitters(mongoose.Mongoose.prototype.Document,"mongoose.lib.document","init");
			clsBindMongoEmitters(mongoose.Mongoose.prototype.Model,"mongoose.lib.model","init");

			clsBindWithCallback(mongoose.Mongoose.prototype.Query.prototype,"mongoose.lib.query.prototype","exec");

	} catch (err) {
		traceOutput.error("mongodb.instrumentMongoose","error requiring submodules for mongoose. "+err);
	}
};

var instrumentMquery = exports.instrumentMquery = function(requiredMod) {

	try {

		var mquery = require(requiredMod);

		var mqueryUtil = require(requiredMod+path.sep+'lib'+path.sep+'utils');

			clsBindCallbackArg(mqueryUtil,"mquery.lib.utils","tick",true);

	} catch (err) {
		traceOutput.error("mongodb.instrumentMquery","error requiring submodules for mquery. "+err);
	}
};
