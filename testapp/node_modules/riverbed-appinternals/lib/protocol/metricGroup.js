/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */
/*******************************************************************************
  Changes:

  - Date   -  UID  --------------------- Description ---------------------
  09/29/2016  ecl  BUG268560: Account for multi-byte characters when getting 
                   the number of bytes in a string.
 ******************************************************************************/

//*****************************
// Output Module
//*****************************

var logger = require('../trace-output-tcp'),
	msgcon = require('../protocol/constants'),
    transportHdr = require('../protocol/transportHeader'),
	msgUtil = require('../protocol/util'),
	msgHeader = require('../protocol/messageHeader');

var logLocation = 'metricGroup';

var createMetricGroup = exports.createMetricGroup = function (buffer, sessionId, metricGroup) {

	// set up header - pass the sessionId
	var msgHeaderLength = msgHeader.encode(buffer.slice(msgcon.TRANSPORT_HDR_LEN), sessionId);

	var msgBodyOffset = msgcon.TRANSPORT_HDR_LEN+msgHeaderLength;
	var msgBody = buffer.slice(msgBodyOffset);

	// track next position
	var offset = 0;

	// Create Metric Group message.
	offset = msgUtil.writeInteger(msgcon.Opcode.CreateMetricGroup, msgBody, offset, 4);
	
	var capacityNeeded = msgcon.TRANSPORT_HDR_LEN + msgHeaderLength + offset; 

	// 14 = 2 ints for string length (8 bytes) + multi-instance byte + int for trigger (4 bytes) + END byte after loop (so we don't have to do a separate check)
	capacityNeeded += 14 + msgUtil.getStringBytes(metricGroup.name) + msgUtil.getStringBytes(metricGroup.description);
	buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
	msgBody = buffer.slice(msgBodyOffset);

	// Group name, description, multi/single instance, and instance trigger function (0 - not implemented)
	offset = msgUtil.writeMsgString(metricGroup.name, msgBody, offset);
	offset = msgUtil.writeMsgString(metricGroup.description, msgBody, offset);
	msgBody[offset++] = metricGroup.instance;
	offset = msgUtil.writeInteger(0, msgBody, offset, 4);
	
	// Add all of the metrics.
	metricGroup.metrics.forEach( function (metric) {

		// 18 = 2 type bytes + 3 ints for string length (12 bytes) + int for trigger (4 bytes) (so we don't have to do a separate check)
		capacityNeeded += 18 + msgUtil.getStringBytes(metric.name) + msgUtil.getStringBytes(metric.displayName) + msgUtil.getStringBytes(metric.description);
		buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
		msgBody = buffer.slice(msgBodyOffset);

		// Metric name, display name, description, type, value function (0 - not implemented)
		msgBody[offset++] = msgcon.DataType.String;
		offset = msgUtil.writeMsgString(metric.name, msgBody, offset);
		offset = msgUtil.writeMsgString(metric.displayName, msgBody, offset);
		offset = msgUtil.writeMsgString(metric.description, msgBody, offset);
		msgBody[offset++] = metric.metricType;
		offset = msgUtil.writeInteger(0, msgBody, offset, 4);
	});
	
	// End message.
	msgBody[offset++] = msgcon.DataType.END;

	var sndLength = offset + msgHeaderLength + msgcon.TRANSPORT_HDR_LEN;
	transportHdr.encode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN), sndLength);

	logger.logDebug(logLocation+'.createMetricGroup', 'msg length:'+sndLength);

	var msg = {"buffer":buffer, "sndLength": sndLength};

	return (msg);
}

var createDataClass = exports.createDataClass = function (buffer, sessionId, metricGroup) {

	// set up header - pass the sessionId
	var msgHeaderLength = msgHeader.encode(buffer.slice(msgcon.TRANSPORT_HDR_LEN), sessionId);

	var msgBodyOffset = msgcon.TRANSPORT_HDR_LEN+msgHeaderLength;
	var msgBody = buffer.slice(msgBodyOffset);

	// track next position
	var offset = 0;
    var instName = "InstanceName";
    
	// Create Data Class message.
	offset = msgUtil.writeInteger(msgcon.Opcode.CreateTypeDefinition, msgBody, offset, 4);

	var capacityNeeded = msgcon.TRANSPORT_HDR_LEN + msgHeaderLength + offset; 

	// 22 = 1 short (2 bytes) + 2 ints (8 bytes) + 2 ints for string length (8 bytes) + 4 types (4 bytes) (so we don't have to do a separate check)
	capacityNeeded += 22 + msgUtil.getStringBytes(metricGroup.name) + instName.length;
	buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
	msgBody = buffer.slice(msgBodyOffset);

	// Group ID and name.
	offset = msgUtil.writeInteger(metricGroup.id, msgBody, offset, 2);
	offset = msgUtil.writeMsgString(metricGroup.name, msgBody, offset);
	
	// Instance name / string.
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(instName, msgBody, offset);
	offset = msgUtil.writeInteger(msgcon.DataType.String, msgBody, offset, 4);

	// Add all of the metrics.
	metricGroup.metrics.forEach( function (metric) {
		
		// 9 = 1 type byte + 1 int for string length (4 bytes) + 1 int (4 bytes) (so we don't have to do a separate check)
		capacityNeeded += 9 + msgUtil.getStringBytes(metric.name);
		buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
		msgBody = buffer.slice(msgBodyOffset);

		// Metric name / data type
		msgBody[offset++] = msgcon.DataType.String;
		offset = msgUtil.writeMsgString(metric.name, msgBody, offset);
		offset = msgUtil.writeInteger(metric.dataType, msgBody, offset, 4);
	});
	
	// End properties.
	msgBody[offset++] = msgcon.DataType.END;
	
	// Instance name identity.
	msgBody[offset++] = msgcon.DataType.Int32;
	offset = msgUtil.writeInteger(0, msgBody, offset, 4);
	
	// End message.
	msgBody[offset++] = msgcon.DataType.END;
	
	var sndLength = offset + msgHeaderLength + msgcon.TRANSPORT_HDR_LEN;
	transportHdr.encode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN), sndLength);
	
	logger.logDebug(logLocation+'.createDataClass', 'msg length:'+sndLength);

	var msg = {"buffer":buffer, "sndLength": sndLength};

	return (msg);
}

