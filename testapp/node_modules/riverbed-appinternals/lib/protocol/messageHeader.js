/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// TODO encode() : assign a real msg request id to track 

var logger = require('../trace-output-tcp'),
	uuid = require('uuid'),
	msgUtil = require('../protocol/util'),
    msgcon = require('../protocol/constants'),
	traceConfig = require('../trace-config');

//-----------------------------
//Internal Constants
//-----------------------------

var NODE_MSG_PROC_UUID = '55cbea87-092c-4da2-a00c-af3949d3429d',
	NODE_MSG_PROC_MAJOR = 1,
	NODE_MSG_PROC_MINOR = 0,
	logLocation = 'messageHeader';

//-----------------------------
//Internal Variables
//-----------------------------

//TODO  create some msg header buffers that do not ever change (e.g. msg processor and msg proc version) that can just be copied into a
//msg header - this should save processing time

var nodeMsgProcUuid = new Buffer(16);

uuid.parse(NODE_MSG_PROC_UUID, nodeMsgProcUuid);  	// (10)  85 203 234 135 9 44 77 162 160 12 175 57 73 211 66 157
													// (16) 55 cb ea 87 09 2c 4d a2 a0 0c af 39 49 d3 42 9d
													// little endian format = a2 4d 2c 09 87 ea cb 55 - 9d 42 d3 49 39 af 0c a0

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// NOTE:  if log messages are needed in the encode method - use console.log (info, etc); 
// Logging from inside any method called (directly or indirectly) as a result of calling 
// trace-output-tcp.logMessage creates the potential for a blown stack 
// (as LogMessage calls LogMessage calls LogMessage.......)

//-----------------------------
//Internal Functions
//-----------------------------

//-----------------------------
//External Functions
//-----------------------------

var encode = exports.encode = function (buffer, sessionId, msgReqId) {
	
	// NOTE - dynamic buffer allocation and length checking purposely not performed here - header length is well-known (max) size
	
	// track next position
	var offset = 0;

	// used flags - send msg processor, msg processor version, and msg id
	buffer[offset] = msgcon.MsgHdrUsedFlag.MsgProcessor | 
					 msgcon.MsgHdrUsedFlag.MsgProcessorVersion;
	
	if(sessionId === undefined || sessionId === -1) {
		offset++;
	} else {
		buffer[offset] = buffer[offset] | msgcon.MsgHdrUsedFlag.SessionId;
		offset++;
		offset = msgUtil.writeInteger(sessionId, buffer, offset, 4);
	}
		
	// write the MsgProcessor UUID
	offset = msgUtil.writeUuid128(nodeMsgProcUuid, buffer, offset);

	// write the MsgProcessor Version
	// server reads this as an int (not two words)
	offset = msgUtil.writeVersion(buffer, offset, NODE_MSG_PROC_MAJOR, NODE_MSG_PROC_MINOR);

	if(msgReqId !== undefined) {

		buffer[0] = buffer[0] | msgcon.MsgHdrUsedFlag.MessageId;
		offset = msgUtil.writeInteger(msgReqId, buffer, offset, 4);
	} 
	// return msgHeader length
	return offset;
}

var decode = exports.decode = function(buffer) {

	var msgHeader = {
			valid			: true,
			hdrLength		: 0,
			gotSessonId		: false,
			gotMsgProc		: false,
			gotMsgProcVer	: false,
			gotRequest		: false,
			sessionId		: 0,
			msgProcessor	: 0,
			msgProcVersion	: 0,
			msgId			: 0
	};
	
	var offset = 0;
	
	if (buffer.length < 1) {
		msgHeader.valid = false;
		logger.logError(logLocation+'.decode','message header is an invalid length'+buffer.length)
		return msgHeader;
	} 
	var usedFlag = buffer[offset++];

	msgHeader.gotSessionId = (usedFlag & msgcon.MsgHdrUsedFlag.SessionId) ? true : false;
	msgHeader.gotMsgProc = (usedFlag & msgcon.MsgHdrUsedFlag.MsgProcessor) ? true : false;
	msgHeader.gotMsgProcVer = (usedFlag & msgcon.MsgHdrUsedFlag.MsgProcessorVersion) ? true : false;
	msgHeader.gotRequest    = (usedFlag & msgcon.MsgHdrUsedFlag.RequestResponse) ? false : true;
	
	var expectedLength = 1;
	expectedLength += (msgHeader.gotSessionId) ? 4 : 0;
	expectedLength += (msgHeader.gotMsgProc) ? 16 : 0;
	expectedLength += (msgHeader.gotMsgProcVer) ? 4 : 0;
	expectedLength += (msgHeader.gotRequest) ? 4 : 0;
	
	if (buffer.length < expectedLength) {
		msgHeader.valid = false;
		logger.logError(logLocation+'.decode','message header length('+buffer.length+') is less than expected('+expectedLength+')');
		return msgHeader;
	} 
	
	if (msgHeader.gotSessionId) {
		msgHeader.sessionId =  msgUtil.readInteger(buffer, offset, 4);
		if (msgHeader.sessionId !== mySessionId) {
			logger.logError(logLocation+'.decode','Invalid sessionId:'+msgHeader.sessionId);
		}
		return msgHeader;
		//offset += 4;
	}
	
	if (msgHeader.gotMsgProc) {
		dumpUuid(buffer, offset);
		
		var strUuid = uuid.unparse(msgUtil.readUuid128(buffer, offset));
		if (strUuid !== NODE_MSG_PROC_UUID) {
			msgHeader.valid = false;
			logger.logError(logLocation+'.decode','unsupported message processor:'+uuidValue);
			return msgHeader;
		}
		offset +=16;
	} 
	if (msgHeader.gotMsgProcVer) {
		// get version if there
		offset +=4;
	}
	if (msgHeader.gotMsgProcVer) {
		// get request id if there
		offset +=4;
	}
	msgHeader.hdrLength = offset;
	return msgHeader;
}

function dumpUuid(buffer, offset) {
	
	if (traceConfig.LOGGING_LEVELS.DEBUG) {
		var uuidStr = "uuid = ";
		
		for (var index = offset; index < offset+16; index++) {
			uuidStr += buffer[index].toString(16);
		}
		logger.logDebug(logLocation+'.dumpUuid', uuidStr);
	}
}
