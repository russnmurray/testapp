/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// Socket.io Instrumentation Module
// *****************************

// required modules
var traceCLS = require('./trace-cls'),
	traceOutputApi = require('./trace-output-api'),
	traceConfig = require('./trace-config'),
	traceUtil = require('./trace-util'),
	path = require('path'),
	hooker = require('hooker');

var totalConnections=0,
	currentConnections=0,
	totalMessagesReceived=0,
	totalMessagesSent=0,
	totalCharsSent=0,
	totalCharsReceived=0;

// -----------------------------
// Internal Functions
// -----------------------------
function hookSocket(socket){

	hooker.unhook(socket.prototype, 'onOpen');
	hooker.hook(socket.prototype, 'onOpen', {
		'post': function engineIOSocketOpenWrapper(){
			var id=this.id;
			// need to still track current connections even if short-circuited
			currentConnections++;
			// don't collect any data if we're short-circuited
			if(!traceConfig.isShortCircuited()) {
				totalConnections++;
				traceOutputApi.debug("engineio.engineIOSocketOpenWrapper", "new socket "+id+" connected");
				traceOutputApi.debug("engineio.engineIOSocketOpenWrapper", "wrapping socket "+id+" as event emitter");
			}
			traceCLS.bindEmitterWithHooks(this,
				function socketEmitterPrev(eventType,name,args){
					// don't collect any data if we're short-circuited
					if(!traceConfig.isShortCircuited()) {
						if(eventType=="data") {
							var msgBody = (args.length>0 && args[0])?args[0]:'';
							if(!(traceUtil.isString(msgBody))) {
								msgBody = JSON.stringify(msgBody);
							}
							var charCount = msgBody.length;
							totalCharsReceived += charCount;
							totalMessagesReceived++;
							traceOutputApi.debug("engineio.socketEmitterPreview", "socket "+id+" received msg '"+msgBody+"' with "+charCount+" chars");
						}
					}
	       		},
	       		function socketEmitterPost(){
	       			// for now do nothing. not tracking dur of handlers in engine.io
	       		}
	       	);
		}
	});
	hooker.unhook(socket.prototype, 'onClose');
	hooker.hook(socket.prototype, 'onClose', {
		'post': function engineIOSocketCloseWrapper(){
			// need to still track current connections even if short-circuited
			traceOutputApi.debug("engineio.engineIOSocketCloseWrapper", "socket "+this.id+" disconnected");
			currentConnections--;
		}
	});

	hooker.unhook(socket.prototype, 'sendPacket');
	hooker.hook(socket.prototype, 'sendPacket', {
		'pre': function engineIOSocketSendWrapper(){
			// don't collect any data if we're short-circuited
			if(!traceConfig.isShortCircuited()) {
				if(arguments && arguments.length>0 && arguments[0]=="message") {
					totalMessagesSent++;
					var msgBody = (arguments.length>1 && arguments[1])?arguments[1]:'';
					if(!(traceUtil.isString(msgBody))) {
						msgBody = JSON.stringify(msgBody);
					}
					var charCount = msgBody.length;
					totalCharsSent += charCount;
					traceOutputApi.debug("engineio.engineIOSocketSendWrapper", "socket "+this.id+" sent msg '"+msgBody+"' with "+charCount+" chars");
				}
			}
		}
	});
};

// -----------------------------
// External Functions
// -----------------------------
var instrumentSocketIO = exports.instrumentSocketIO = function(requiredMod) {

	var socket = require(requiredMod+path.sep+'socket');
	hookSocket(socket);
};

var getTotalConnections = exports.getTotalConnections = function() {
	return totalConnections;
};

var getCurrentConnections = exports.getCurrentConnections = function() {
	return currentConnections;
};

var getTotalMessagesReceived = exports.getTotalMessagesReceived = function() {
	return totalMessagesReceived;
};

var getTotalMessagesSent = exports.getTotalMessagesSent = function() {
	return totalMessagesSent;
};

var getTotalCharsReceived = exports.getTotalCharsReceived = function() {
	return totalCharsReceived;
};

var getTotalCharsSent = exports.getTotalCharsSent = function() {
	return totalCharsSent;
};
