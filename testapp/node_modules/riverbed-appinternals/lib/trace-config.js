/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// Config Module
// *****************************

// required modules
var traceUtil = require('./trace-util'),
	os = require('os'),
	fs = require('fs'),
	path = require('path'),
	osHomeDir = require('os-homedir')(),
	traceMoniker = require('./trace-moniker'),
	traceOutputApi = require('./trace-output-api');

// -----------------------------
// Constants
// -----------------------------

var mapOsToDaConfigFileDir = {
	'Linux' : 		'/var/tmp',
	'Darwin' :  	'/var/tmp',
	'Windows_NT' : 	(
						process.env.ALLUSERSPROFILE
						?
						path.join(path.join(process.env.ALLUSERSPROFILE,"Riverbed"),"AppInternals")
						:
						undefined
					)
	// !!!!!! TODO: what location for Sun?
	// 'SunOS' : 		'?????',
	// !!!!!! TODO: what location for Others?
};

// log levels
var LOGGING_LEVELS = exports.LOGGING_LEVELS = {
		ERROR : 0,
		WARN : 1,
		INFO : 2,
		DEBUG: 3
};
var LOGGING_LEVEL_STRS = exports.LOGGING_LEVEL_STRS = {
		0 : "ERROR",
		1 : "WARN",
		2 : "INFO",
		3 : "DEBUG"
};

var filenamePrefix = ".appinternals.",
	filenameHookedSuffix = ".hooked",
	filenameUnhookedSuffix = ".unhooked";

// -----------------------------
// Internal Variables
// -----------------------------
var instrument = true,
	shortCircuit = true,
	sendEUEResponseHeaders = true,
	allowNativeDependencies = true,
	monitorEventLoop = false,
	debugMode = false,
	logLevel = LOGGING_LEVELS.ERROR,
	DAConnected = false;

// -----------------------------
// Internal Functions
// -----------------------------

// gets the modified timestamp for a file if it exists
// returns null otherwise
function getModifiedTimestampSync(filePath, fileName) {
	try {
			var fd = fs.openSync(path.join(filePath,fileName),'r');	// mode is "read" and exception if file doesn't exist
			var timestamp = fs.fstatSync(fd).mtime.getTime();
			fs.closeSync(fd);
			return timestamp;
	} catch(err) {
		return null;
	}
};

// updates the JS config file state
function updateJSHookedConfigState(shouldHook) {
	var moniker = traceMoniker.getProcessMoniker(),
		toWriteFilename = filenamePrefix+traceMoniker.getProcessMoniker()+(shouldHook?filenameHookedSuffix:filenameUnhookedSuffix),
		toRemoveFilename = filenamePrefix+traceMoniker.getProcessMoniker()+(shouldHook?filenameUnhookedSuffix:filenameHookedSuffix);
	var JSConfigOutputDir = osHomeDir;

	if(traceUtil.isString(JSConfigOutputDir)) {
		// STEP1: make sure we write out the new state first
		try {
			// open the file to write
			var fd = fs.openSync(path.join(JSConfigOutputDir,toWriteFilename),'w');	// mode is "write" and create if file does not exist.
			// close the file
			fs.closeSync(fd);
			traceOutputApi.debug("trace-config.updateJSHookedConfigState","Set JS Hook/Unhook config file state to "+(shouldHook?"hooked":"unhooked")+".");
		} catch(err) {
			traceOutputApi.warn("trace-config.updateJSHookedConfigState","Could not set JS Hook/Unhook config file state to "+(shouldHook?"hooked":"unhooked")+" because of a filesystem error: "+err);
		}

		// STEP2: try to delete the old state
		try {
			fs.unlinkSync(path.join(JSConfigOutputDir,toRemoveFilename));
		} catch(err) {
			traceOutputApi.warn("trace-config.updateJSHookedConfigState","While setting JS Hook/Unhook config file state to "+(shouldHook?"hooked":"unhooked")+", failed to remove file: "+toRemoveFilename);
		}

	} else {
		// log a warning that we couldn't find JS config files
		traceOutputApi.warn("trace-config.updateJSHookedConfigState","Could not set JS Hook/Unhook config file state to "+(shouldHook?"hooked":"unhooked")+" because directory was not found for platform "+process.platform);
	}
};

function getHookedState(hookedTimestamp,unhookedTimestamp,dirForLogMsgs) {

	var isHooked = null;

	if(hookedTimestamp != null) {
		// have a .hooked file in the directory
		if(unhookedTimestamp != null) {
			// also have a .unhooked file in the directory.
			// go based on timestamps
			isHooked = hookedTimestamp > unhookedTimestamp;
			// log a warning about having both files
			traceOutputApi.warn("trace-config.init",
				"Found both a "+filenameHookedSuffix+" and a "+filenameUnhookedSuffix+" file in "+dirForLogMsgs+" Hook/Unhook config file directory. "+
				"Considering status "+(isHooked?"hooked":"unhooked")+" based on timestamps.");
		} else {
			isHooked = true;
		}
	} else {
		// no .hooked file
		if(unhookedTimestamp != null) {
			// have a .unhooked file
			isHooked = false;
		} else {
			// don't have a .hooked or a .unhooked file
			// keep isHooked as null
			isHooked = null;
			// log a warning about this
			traceOutputApi.warn("trace-config.init",
				"Found neither a "+filenameHookedSuffix+" nor a "+filenameUnhookedSuffix+" file in "+dirForLogMsgs+" Hook/Unhook config file directory.");
		}
	}

	return isHooked;
};

// -----------------------------
// External Functions
// -----------------------------

var init = exports.init = function(options) {
	
	// NOTE: All fs operations in this function should be synchronous!!!
	// We want to block the application from starting up until we know if we should hook or not.
	// Have to finish reading this config before we can do that.
	// This can NOT be done asynchronously

	// STEP1: Read JavaScript instrumentation line options
	// if any options have been specified on the JS instrumentation line, we will start with those
	if(options) {
		if(typeof options.instrument === 'boolean') {
			instrument = options.instrument;
		}
		// // NOTE: for v1 we aren't allowing users to turn off shortCircuiting via the line of JavaScript
		// // in order to support that we would need to handle some buffering of trace data until the TCP
		// // connection to the DA can be established. 
		// if(typeof options.shortCircuit === 'boolean') {
		// 	setShortCircuited(options.shortCircuit);
		// }
		if(typeof options.eue === 'boolean') {
			setSendEUEResponseHeaders(options.eue);
		}
		if(typeof options.nativeMods === 'boolean') {
			setAllowNativeDependencies(options.nativeMods);
		}
		if(typeof options.debug === 'boolean') {
			setDebugMode(options.debug);
		}
		if(typeof options.monitorEventLoop === 'boolean') {
			setMonitorEventLoop(options.monitorEventLoop);
		}
	}

	// STEP2: Look for config files in DA and JS directories
	var moniker = traceMoniker.getProcessMoniker(),
		hookedFilename = filenamePrefix+moniker+filenameHookedSuffix,
		unhookedFilename = filenamePrefix+moniker+filenameUnhookedSuffix;
	var DAConfigOutputDir = mapOsToDaConfigFileDir[os.type()],
		JSConfigOutputDir = osHomeDir,
		DAHookedTimestamp = null,
		JSHookedTimestamp = null,
		DAUnhookedTimestamp = null,
		JSUnhookedTimestamp = null;

	if (traceUtil.isString(DAConfigOutputDir)) {
		traceOutputApi.debug("trace-config.init","DA Hook/Unhook config file directory is "+DAConfigOutputDir);
		DAHookedTimestamp = getModifiedTimestampSync(DAConfigOutputDir,hookedFilename);
		DAUnhookedTimestamp = getModifiedTimestampSync(DAConfigOutputDir,unhookedFilename);
	} else {
		// log a warning that we couldn't find DA config files
		traceOutputApi.warn("trace-config.init","DA Hook/Unhook config file directory was not found for OS "+os.type());
	}

	if(traceUtil.isString(JSConfigOutputDir)) {
		traceOutputApi.debug("trace-config.init","JS Hook/Unhook config file directory is "+JSConfigOutputDir);
		JSHookedTimestamp = getModifiedTimestampSync(JSConfigOutputDir,hookedFilename);
		JSUnhookedTimestamp = getModifiedTimestampSync(JSConfigOutputDir,unhookedFilename);
	} else {
		// log a warning that we couldn't find JS config files
		traceOutputApi.warn("trace-config.init","JS Hook/Unhook config file directory was not found for platform "+process.platform);
	}

	// STEP3: Determine config state in DA and JS directories based on timestamps

	var DAHooked = getHookedState(DAHookedTimestamp,DAUnhookedTimestamp,"DA"),
		JSHooked = getHookedState(JSHookedTimestamp,JSUnhookedTimestamp,"JS");

	// STEP4: Determine config state in JS directory based on timestamps and set the "instrument" flag

	if(DAHooked != null) {
		if(JSHooked!=null) {
			if(JSHooked == DAHooked) {
				// hooked states match
				// no need to log, just use either of them (they are the same)
				instrument = DAHooked;
			} else {
				// hooked states don't match, need to compare timestamps
				var DATimestamp = (DAHooked?DAHookedTimestamp:DAUnhookedTimestamp),
					JSTimestamp = (JSHooked?JSHookedTimestamp:JSUnhookedTimestamp);

				if(DATimestamp > JSTimestamp) {
					// DA file is more recent
					traceOutputApi.warn("trace-config.init","DA and JS Hook/Unhook config don't agree. Using DA config status "+(DAHooked?"hooked":"unhooked")+" based on timestamps.");
					instrument = DAHooked;
				} else {
					if(JSTimestamp > DATimestamp) {
						// JS file is more recent
						traceOutputApi.warn("trace-config.init","DA and JS Hook/Unhook config don't agree. Using JS config status "+(JSHooked?"hooked":"unhooked")+" based on timestamps.");
						instrument = JSHooked;
					} else {
						// timestamps are identical.
						// log that we are falling back to static default of to unhooked as a failsafe
						traceOutputApi.warn("trace-config.init","DA and JS Hook/Unhook config don't agree and have identical timestamps. Using unhooked status as a failsafe.");
						instrument = false;
					}

				}
			}
		} else {
			// only found DA config files. 
			// already logged no JS config files in getHookedState.
			// just use DA state
			instrument = DAHooked;
		}
	} else {
		if(JSHooked!=null) {
			// only found JS config files. 
			// already logged no DA config files in getHookedState.
			// just use JS state
			instrument = JSHooked;
		} else {
			// didn't find any config files at all that we could use
			// already logged this independently, but log again to call out that we are using a static default of hooked.
			// we default to hooked because this typically comes up for the initial startup case and we don't want to incur a "double restart"
			traceOutputApi.warn("trace-config.init","Didn't find any DA or JS Hook/Unhook config files. Defaulting to hooked status. This is expected for the first startup of this moniker.");
			instrument = true;		
		}
	}

	traceOutputApi.debug("trace-config.init","Started up in state "+(instrument?"hooked":"unhooked"));
}

// NOTE: this will update the config files in the JS config file directory (home dir)
// This happens in a synchronous manner
var setShouldInstrument = exports.setShouldInstrument = function(shouldInstrument) {
	instrument = shouldInstrument;
	updateJSHookedConfigState(shouldInstrument);
};

var shouldInstrument = exports.shouldInstrument = function() {
	return instrument;
};

var setShortCircuited = exports.setShortCircuited = function(shouldShortCircuit) {
	shortCircuit = shouldShortCircuit;
};

var isShortCircuited = exports.isShortCircuited = function() {
	return shortCircuit;
};

var setSendEUEResponseHeaders = exports.setSendEUEResponseHeaders = function(shouldSend) {
	sendEUEResponseHeaders = shouldSend;
};

var isSendEUEResponseHeaders = exports.isSendEUEResponseHeaders = function() {
	return sendEUEResponseHeaders;
};

var setAllowNativeDependencies = exports.setAllowNativeDependencies = function(shouldAllow) {
	allowNativeDependencies = shouldAllow;
};

var isAllowNativeDependencies = exports.isAllowNativeDependencies = function() {
	return allowNativeDependencies;
};

var setMonitorEventLoop = exports.setMonitorEventLoop = function(shouldMonitor) {
	monitorEventLoop = shouldMonitor;
}

var isMonitorEventLoop = exports.isMonitorEventLoop = function() {
	return monitorEventLoop;
}

var setDebugMode = exports.setDebugMode = function(isDebugMode) {
	debugMode = isDebugMode;
};

var isDebugMode = exports.isDebugMode = function() {
	return debugMode;
};

var getLogLevel = exports.getLogLevel = function() {
	return logLevel;
};

var setLogLevel = exports.setLogLevel = function(level) {
	logLevel = level;
};

var isDAConnected = exports.isDAConnected = function() {
	return DAConnected;
};

var setDAConnected = exports.setDAConnected = function(isConnected) {
	DAConnected = isConnected;
};

var shouldLogToDa = exports.shouldLogToDa = function(severity, location, msg) {
	// is logging level fine enough that we should record this?
	// for DEBUG, INFO, and WARN level, drop messages if DA isn't connected
	var shouldLog = (DAConnected && getLogLevel() >= severity) ;
	
	// in debug mode, output to the console as well   OR
	// for ERROR level only we want to log locally if not connected to DA
	if(isDebugMode() || (!isDAConnected() && severity <= LOGGING_LEVELS.ERROR)) {
		console.log("[Riverbed Tracing] "+Date.now()+" - "+location+" - "+msg);
	}
	return shouldLog;
};

