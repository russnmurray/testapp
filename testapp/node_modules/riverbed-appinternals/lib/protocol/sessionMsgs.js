/* ****************************
** Copyright (c) 2017        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

var logger = require('../trace-output-tcp'),
	transportHdr = require('../protocol/transportHeader'),
	msgHeader = require('../protocol/messageHeader'),
	msgUtil = require('../protocol/util'),
	msgcon = require('../protocol/constants');

//-----------------------------
//Internal Constants
//-----------------------------

//TODO  what should these strings be?  Do we need to send Build over?
var DA_NAME = "NodeJS",
    DA_VERSION = "10.12",
    DA_BUILD = "123",
    DA_INSTANCE = "",
    logLocation = 'sessionMsgs';

//-----------------------------
//External Functions
//-----------------------------

var encodeBegin = exports.encodeBegin = function (buffer, moniker, pid, longContainerID, containerHostName) {

	// TODO - send valid msg request Id

	// NOTE - dynamic buffer allocation purposely not performed here - msg length is well-known size

	// set up header
	var msgHeaderLength = msgHeader.encode(buffer.slice(msgcon.TRANSPORT_HDR_LEN), -1, 2);

	var msgBody = buffer.slice(msgcon.TRANSPORT_HDR_LEN+msgHeaderLength);

	// track next position
	var offset = 0;

	// identify message as a BeginSession
	offset = msgUtil.writeInteger(msgcon.Opcode.BeginSession, msgBody, offset, 4); // value, offset, length
	offset = msgUtil.writeMsgString(DA_NAME, msgBody, offset);
	offset = msgUtil.writeMsgString(moniker, msgBody, offset);
	offset = msgUtil.writeInteger(pid, msgBody, offset, 4); // value, offset, length
	offset = msgUtil.writeMsgString(DA_VERSION, msgBody, offset);
	offset = msgUtil.writeMsgString(DA_BUILD, msgBody, offset);
	offset = msgUtil.writeMsgString(DA_INSTANCE, msgBody, offset);

	// There is a container ID (should be 32 bytes), send it.
	if (longContainerID != null && longContainerID.length > 0) {

		offset = msgUtil.writeMsgString(longContainerID, msgBody, offset);

	// No container ID, send an empty string.
	} else {

		offset = msgUtil.writeMsgString("", msgBody, offset);
	}

	// There is a container hostname, send it.
	if (containerHostName != null && containerHostName.length > 0) {

		offset = msgUtil.writeMsgString(containerHostName, msgBody, offset);

	// No container hostname, send an empty string.
	} else {

		offset = msgUtil.writeMsgString("", msgBody, offset);
	}

	var sndLength = offset + msgHeaderLength + msgcon.TRANSPORT_HDR_LEN;
	transportHdr.encode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN), sndLength);

	//logger.logDebug(logLocation+'.encodeBegin', 'msg length:'+sndLength);

	var msg = {"buffer":buffer, "sndLength": sndLength};
	return msg;
}

var encodeEnd = exports.encodeEnd = function(buffer, sessionId) {

	// NOTE - dynamic buffer allocation purposely not performed here - msg length is well-known size

	// set up header
	var msgHeaderLength = msgHeader.encode(buffer.slice(msgcon.TRANSPORT_HDR_LEN), sessionId);

	var msgBody = buffer.slice(msgcon.TRANSPORT_HDR_LEN+msgHeaderLength);

	// track next position
	var offset = 0;

	// identify message as an EndSession
	offset = msgUtil.writeInteger(msgcon.Opcode.EndSession, msgBody, offset, 4); // value, offset, length

	var sndLength = offset + msgHeaderLength + msgcon.TRANSPORT_HDR_LEN;
	transportHdr.encode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN), sndLength);

	logger.logDebug(logLocation+'.encodeEnd', 'msg length:'+sndLength);

	var msg = {"buffer":buffer, "sndLength": sndLength};
	return msg;
}
