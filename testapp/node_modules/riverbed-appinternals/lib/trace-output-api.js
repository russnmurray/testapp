/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// Output Module (API) - Abstracts from whether to use output to disk directly or via child process.
// *****************************

// required modules
var traceConfig = require('./trace-config'),
	traceMoniker = require('./trace-moniker'),
	traceOutputFs = require('./trace-output-file'),
	traceProfile = require('./trace-profile'),
	traceEnv = require('./trace-env'),
	os = require('os'),
	path = require('path'),
	fs = require('fs');

require('dns').lookup(os.hostname(), function (err, addr, fam) {
	  ipaddr = addr;
})


// -----------------------------
// Internal Variables
// -----------------------------
var outputDirName = "rvbdoutput",
	outputPath,
	outputDirExists = false,
	traceStartTime = Date.now(),
	outputProcess,
	id,
	initArg,
	currentlyShortCircuited,
	exitListenerAdded = false,
	outputTcpProcess,
	ipaddr;

// -----------------------------
// Internal Functions
// -----------------------------

function shutdownOutputProcess(){
	shutdownFileOutputProcess();
	shutdownTcpOutputProcess();
};

function shutdownFileOutputProcess(){
	// check that outputProcess is truthy in case instrumentation has been short-circuited during runtime
	if(outputProcess && outputProcess.connected) {
		outputProcess.disconnect();
		outputProcess = null;
	}
};

function shutdownTcpOutputProcess(){
	// check that outputProcess is truthy in case instrumentation has been short-circuited during runtime
	if(outputTcpProcess && outputTcpProcess.connected) {
		outputTcpProcess.disconnect();
		outputTcpProcess = null;
	}
};

// -----------------------------
// External Functions
// -----------------------------

var init = exports.init = function(resultsDir) {
	// stash the initialization arg for later
	// if we're short circuited now or in the future
	// we'll need to remember these in case short circuiting is turned off
	initArg = resultsDir;
	currentlyShortCircuited = traceConfig.isShortCircuited();

	// only output to file if (A) we aren't short-circuited and (B) we're in debug mode
	// in prod mode we only output over TCP
	if(!currentlyShortCircuited && traceConfig.isDebugMode()) {
		var dir = (resultsDir?resultsDir:process.cwd());	// if resultsDir wasn't specified use current working dir
		id = traceMoniker.getProcessMoniker();

		outputPath = path.join(dir,outputDirName);

		var childpath = module.filename.substring(0,module.filename.length-"trace-output-api.js".length);

		// see if output path exists yet, if not create it
		fs.exists(outputPath,function(exists){
			if(exists) {
				debug('trace-output-api.init','output directory '+outputPath+' already exists.');
				outputDirExists = true;
				// outputPath exists already
				// fork the child
				// first arg is directory to output results either current working directory or resultsDir if specified
				// second arg is id for identifying results
				outputProcess = require('child_process').fork(childpath+'/trace-output-process-file.js',[outputPath,id,process.pid,traceStartTime]);
			} else {
				debug('trace-output-api.init','creating output directory '+outputPath);
				fs.mkdir(outputPath,function(){
					debug('trace-output-api.init','created output directory '+outputPath);
					outputDirExists = true;
					// outputPath exists now
					// fork the child
					// first arg is directory to output results either current working directory or resultsDir if specified
					// second arg is id for identifying results
					outputProcess = require('child_process').fork(childpath+'/trace-output-process-file.js',[outputPath,id,process.pid,traceStartTime]);
				});
			}
		});

		if(!exitListenerAdded) {	
			// don't want to add multiple "exit" event listeners
			// only add one the first time through
			process.on("exit",function(){
				// need to tear down child process whenever main process is done.
				shutdownOutputProcess();
			});
			exitListenerAdded = true;
		}
	}
}

var connectDA = exports.connectDA = function(options) {
	// stash the initialization arg for later
	// if we're short circuited now or in the future
	// we'll need to remember these in case short circuiting is turned off

	var moniker = traceMoniker.getProcessMoniker();
	var childpath = module.filename.substring(0,module.filename.length-"trace-output-api.js".length);

	// first arg is the port on the NodeDA to connect to
	// second arg is id for identifying results (moniker)
	// third arg is this process's PID
	outputTcpProcess = require('child_process').fork(childpath+'/trace-output-process-tcp.js',[JSON.stringify(options || {}),moniker,process.pid]);
	outputTcpProcess.on('exit', function() {
		// NOTE: setting the child process to null is NOT sufficient to prevent all access to the child process. 
		// Any method currently in progress and accessing the child process when it exits would get an EPIPE error.
		// Protect this process by wrapping all references to child process in a try-catch
		outputTcpProcess = null;
		
		// stop instrumentation
		traceConfig.setDAConnected(false);
		traceConfig.setShortCircuited(true);
		updateShortCircuiting();
		traceEnv.updateShortCircuiting();

		// this print to the console
		error('outputTcpProcess.on(exit)', 'The instrumentation TCP client process has exited, restarting...');
		connectDA(options);
	});
	outputTcpProcess.on('message',function(message){
		// TODO  Not supporting CPU profiling or heapsnapshots yet; 
		//	this code also resides in trace-input-api; if that functionality remains, we might want to move it and share it
		if(message){
			if(message.type == 'profile') {
				//if(message.id) {
				//	if(message.action=='start') {
				//		debug('trace-output-api.message','received profiling start command with id: '+message.id);
				//		traceProfile.startProfiling(message.id);
				//	} else if (message.action=='stop') {
				//		debug('trace-output-api.message','received profiling stop command with id: '+message.id);
				//		traceProfile.stopProfiling(message.id);
				//	}
				//}
			} else if(message.type == 'heapsnapshot') {
				//if(message.id) {
				//	debug('trace-output-api.message','received heap snapshot command with id: '+message.id);
				//	traceProfile.takeSnapshot(message.id);
				//}
			} else if (message.type == 'shortcircuit') {
				if(message.isShortCircuit != traceConfig.isShortCircuited() ) {
					// only do something if there's actually a change of state
					traceConfig.setShortCircuited(message.isShortCircuit);
					updateShortCircuiting();
					traceEnv.updateShortCircuiting();
				}
			} else if (message.type == 'instrument') {
				traceConfig.setShouldInstrument(message.hook);
			} else if (message.type == 'sendeueresphdrs') {
				traceConfig.setSendEUEResponseHeaders(message.send);
			} else if (message.type == 'daConnectState') {
				traceConfig.setDAConnected(message.connected);
			} else if (message.type == 'loglevel') {
				traceConfig.setLogLevel(message.level);
			}
		}
	});

	// set env properties
	var envProps = {
		processid   		: process.pid,
		user 	      		: (process.env.USER?process.env.USER:''),
		"Node name"	  		: process.title,
		"Node version" 		: process.version,
		"current directory" : process.cwd()
		//"current directory" : process.cwd(),
		//datype				: "NODEJS",
		//"Operating System"	: os.type(),
		//"node"				: os.hostname()+"/"+ipaddr
	};
	
	try {
		if(outputTcpProcess && outputTcpProcess.connected) {
			// need these initialized before any data is sent to outputTcpProcess
			outputTcpProcess.send({'debugMode':traceConfig.isDebugMode()});
			outputTcpProcess.send({'envProps':envProps});

			if(!exitListenerAdded) {	
				// don't want to add multiple "exit" event listeners
				// only add one the first time through
				process.on("exit",function(){
					// need to tear down child process whenever main process is done.
					shutdownOutputProcess();
				});
				exitListenerAdded = true;
			}
		}
	} catch (err) {	}  // in case the child process died
}

// send the result to the appropriate output handler to get persisted at some point
var addTraceResult = exports.addTraceResult = function(tracingData) {
	if (!currentlyShortCircuited) {
		try {
			// always output over TCP
			if(outputTcpProcess && outputTcpProcess.connected) {
				outputTcpProcess.send({'trace':tracingData});
			}
			// output to file in DEBUG mode
			if(outputProcess && traceConfig.isDebugMode()) {
				outputProcess.send({'trace':tracingData});
			}
		}  catch (err) {	}  // in case the child process died
	}
};

var addEnvResult = exports.addEnvResult = function(envData) {
	
	if (!currentlyShortCircuited) {

		try {
			// Send to NodeDA
			if(outputTcpProcess && outputTcpProcess.connected) {
				outputTcpProcess.send({'env':envData});
			}
			// output to file only in DEBUG mode
			if(outputProcess && traceConfig.isDebugMode()) {
				outputProcess.send({'env':envData});
			}
		} catch (err) {	}  // in case the child process died
	}
};

var addProfileResult = exports.addProfileResult = function(id,profile) {
	//TODO	- send to NodeDA
	if(!currentlyShortCircuited) {
		if(outputDirExists) {
			traceOutputFs.persistProfileResult(outputPath,traceMoniker.getProcessMoniker(),id,profile);
		} else {
			error('trace-output-api.addProfileResult','cannot save profile because output directory does not exist yet');
		}
	}
};

var addSnapshotResult = exports.addSnapshotResult = function(id,snapshot) {

	//TODO	- send to NodeDA
	if(!currentlyShortCircuited) {
		if(outputDirExists) {
			traceOutputFs.persistSnapshotResult(outputPath,traceMoniker.getProcessMoniker(),id,snapshot);
		} else {
			error('trace-output-api.addSnapshotResult','cannot save snapshot because output directory does not exist yet');
		}
	}
};

var updateShortCircuiting = exports.updateShortCircuiting =function() {

	// check that current short circuit state is different from current one
	// to prevent duplicate toggling of shortCircuit from on to on or from off to off
	// that could potentially cause bad things to happen
	// e.g. creating a second child process
	if(currentlyShortCircuited != traceConfig.isShortCircuited()) {
		// update current short circuit status
		currentlyShortCircuited = traceConfig.isShortCircuited();
		if(currentlyShortCircuited) {
			// need to do short circuiting
			// this is handled by
			// (1) updating status flag done above
			// (2) shutting down the file outputProcess
			shutdownFileOutputProcess();
		} else {
			// need to rewire so short circuiting is off
			// this is handled by
			// (1) updating status flag done above
			// (2) call init with the args passed in originally
			init(initArg);
		}
	}
};

var getTraceStartTime = exports.getTraceStartTime = function() {
	return traceStartTime;
};

var debug = exports.debug = function(location,msg) {
	try {
		// is logging level fine enough that we should record this?
		if(traceConfig.shouldLogToDa(traceConfig.LOGGING_LEVELS.DEBUG,location,msg) && outputTcpProcess) {
			// send message downstream for logging over TCP
			outputTcpProcess.send({
				'log':{
					'msg':location+" - "+msg,
					'level':traceConfig.LOGGING_LEVELS.INFO
				}
			});
		}
	} catch (err) {	}  // in case the child process died
};

var info = exports.info = function(location,msg) {
	try {
		// is logging level fine enough that we should record this?
		if(traceConfig.shouldLogToDa(traceConfig.LOGGING_LEVELS.INFO,location,msg) && outputTcpProcess) {
			// send message downstream for logging over TCP
			outputTcpProcess.send({
				'log':{
					'msg':location+" - "+msg,
					'level':traceConfig.LOGGING_LEVELS.INFO
				}
			});
		}
	} catch (err) {	}  // in case the child process died
};

var warn = exports.warn = function(location,msg) {
	try {
		// is logging level fine enough that we should record this?
		if(traceConfig.shouldLogToDa(traceConfig.LOGGING_LEVELS.WARN,location,msg) && outputTcpProcess) {
			// send message downstream for logging over TCP
			outputTcpProcess.send({
				'log':{
					'msg':location+" - "+msg,
					'level':traceConfig.LOGGING_LEVELS.WARN
				}
			});
		}
	} catch (err) {	}  // in case the child process died
};

var error = exports.error = function(location,msg) {
	try {
		// is logging level fine enough that we should record this?
		if(traceConfig.shouldLogToDa(traceConfig.LOGGING_LEVELS.ERROR,location,msg) && outputTcpProcess) {
			// send message downstream for logging over TCP
			outputTcpProcess.send({
				'log':{
					'msg':location+" - "+msg,
					'level':traceConfig.LOGGING_LEVELS.ERROR
				}
			});
		} 
	} catch (err) {	}  // in case the child process died
};
