/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// HTTP(S) Instrumentation Module
// *****************************

// required modules
var http = require('http'),
	https = require('https'),
	hooker = require('hooker'),
	traceUtil = require('./trace-util'),
	util = require('util'),
	urlLib = require('url'),
	uuid = require('uuid'),
	traceConfig = require('./trace-config'),
	traceCLS = require('./trace-cls'),
	traceEvent = require('./trace-event'),
	traceOutput = require('./trace-output-api');

// -----------------------------
// Constants
// -----------------------------
var traceHeaderName = "X-OPNET-Transaction-Trace",
	pidHeaderName = "X-OPNET-AIX-PAGEID",
	cookieName = "_op_aixPageId";

// -----------------------------
// Internal Variables
// -----------------------------

// current counter for txn id
var nextTxnId = 0;

// counters for tracking request concurrency/rate
var inboundRequestsReceived = 0,
	currentInboundRequests = 0,
	outboundRequestsReceived = 0,
	currentOutboundRequests = 0;

// -----------------------------
// Internal Functions
// -----------------------------

function getHeaderCaseInsensitive(headersObj,headerKey) {
	if(!(headersObj && traceUtil.isString(headerKey))) {
		return '';
	}
	var lowerHeaderKey = headerKey.toLowerCase();
	for (var key in headersObj) {
		if (headersObj.hasOwnProperty(key) && key.toLowerCase() === lowerHeaderKey) {
			return headersObj[key];
		}
	}
};

var wrapServerEmitter = function(protocol){ 
	return traceEvent.wrapEventEmitterHandlerToPreview(['request'],function(event,userHandler,args){

		var request = args[0],
		response = args[1];

		// only collect data if not short-circuited
		// NOTE: if we are not short-circuited at the time the inbound request comes in, we will completely finish handling it,
		// even if we are short-circuited mid-way through the request.
		if (traceConfig.isShortCircuited()) {
			// Just call the original call back
		    userHandler(request, response);
		} else {

			traceOutput.debug(protocol+'.wrapServerEmitter','handling request event');

			// increment our counters for tracking request concurrency/rate
			inboundRequestsReceived++;
			currentInboundRequests++;

			// grab the txn Id and increment
			var txId = nextTxnId;
			nextTxnId++;

			// generate _op_aixglobaltransid
			var globalTransId = 'a2_'+uuid.v4();

			// injected headers for this inbound request
			var receivedInjHeader,
				sentInjHeader;


			// storage object for tracing data
			var CLSTraceData = {
				'txId' 					: txId,
				'nextAsyncId'			: 1,	// start at 1 so 0 can be a default if something goes wrong
				'exceptionsStack'		: [],
				'finished'				: false,
				'callDepth'				: 0
			};

			var requestTraceData = {
				'type'					: 'start',
				// transaction id and thread id.
				// these are the same because we use one thread per txn
				'txId' 					: txId,
				'file' 					: '',
				'method'				: '(root)',
				'category' 				: 'Async',
				'props'					: [{'name':'_op_aixglobaltransid','value':globalTransId}],
				'time' 					: Date.now()
			};

			if(request) {
				// set URL if present
				if(request.url) {
					var parsedUrl = urlLib.parse(request.url);
					if(parsedUrl.host || parsedUrl.hostname) {
						requestTraceData.props.push({'name':'url','value':request.url});
					} else if(request.headers && request.headers.host) {
						var headersHost = request.headers.host;
						var urlStr = protocol+'://'+headersHost+((request.url.length>0 && request.url.substring(0,1)=='/')?'':'/')+request.url;
						requestTraceData.props.push({'name':'url','value':urlStr});
					}
				}
				// set user's IP
				if(request.socket && request.socket.remoteAddress) {
					requestTraceData.props.push({'name':'client','value':request.socket.remoteAddress});
				}
				// set http method
				requestTraceData.props.push({'name':'http.method','value':request.method});
				// read injected id from injected header if present
				receivedInjHeader = getHeaderCaseInsensitive(request.headers,traceHeaderName);
				if(receivedInjHeader) {
					requestTraceData.props.push({
						'name' : 'receivedrequestinjectedheader',
						'value' : receivedInjHeader
					});
				}
			}

			traceOutput.addTraceResult(requestTraceData);
			// increment open call count
		    CLSTraceData.callDepth++;
			// add an array to track exceptions for this call
			traceUtil.safePushExceptionsStack(CLSTraceData,[]);

		    // Set up a continuation-local-storage context specific to this request
		    // This context should follow any subsequent ASYNC calls spawned from this request.
		    // The params request and response are EventEmitters, which I think translates to
		    // us needing to bind explicitly here:
		    //    https://www.npmjs.com/package/continuation-local-storage#namespace-bindemitter-emitter
		    traceCLS.bindEmitter(request);
		    traceCLS.bindEmitter(response);

		    // Hook writing headers for this INCOMING request.
		    // Unhook writeHead in case already hooked
		    hooker.unhook(response, "writeHead");
		    // before writing the head, add our special header
		    hooker.hook(response, "writeHead",
		    	{
			        'pre': function(){
			        	// inject tracing header
			        	sentInjHeader = sentInjHeader?sentInjHeader:uuid.v4();
			        	response.setHeader(traceHeaderName,sentInjHeader);
			        	traceOutput.debug(protocol+".ServerResponse.writeHead","set header "+traceHeaderName+": "+sentInjHeader);
			            // inject our EUE header with a unique id
			            if(traceConfig.isSendEUEResponseHeaders()){
				            response.setHeader(pidHeaderName,globalTransId);
				            var setCookieValues = [],
				            	existingCookies = response.getHeader('Set-Cookie');
				            if(existingCookies) {
				            	if(util.isArray(existingCookies)) {
				            		setCookieValues = existingCookies;
				            	} else if (traceUtil.isString()){
				            		setCookieValues.push(existingCookies);
				            	}
				            	setCookieValues.push(cookieName+'='+globalTransId+"; Path=/");
				            } else {
				            	// doesn't seem to work to have a single value array, so use just a string then
				            	setCookieValues = cookieName+'='+globalTransId+"; Path=/";
				            }
				            response.setHeader('Set-Cookie',setCookieValues);
				            traceOutput.debug(protocol+".ServerResponse.writeHead","set header "+pidHeaderName+": "+globalTransId);
				        }
			        },
			       'passName': false
			    } 
			);

		    // set up the CLS context that is specific to this request:
		    traceCLS.run(function() {
		        // store the trace data in CLS
		        traceCLS.setData(CLSTraceData);
		        traceOutput.debug(protocol+".requestListenerWrapper", "stored trace for incoming request "+txId);
		        
		        // handle when response is done being written. should have access to data in CLS here
		        response.addListener("finish",function(){
		        	// don't close out the transaction twice
		        	if (CLSTraceData && !CLSTraceData.finished) {
		        		CLSTraceData.finished = true;
			        	// decrement our counters for tracking request concurrency
						currentInboundRequests--;

						while(CLSTraceData.callDepth > 1) {
				        	// close out outstanding interal calls now
					        traceOutput.addTraceResult({
					        	'type' 		: 'end',
					        	'txId' 		: txId,
					        	'time'		: Date.now(),
					        	'exceptions' 	: traceUtil.safePopExceptionsStack(CLSTraceData)
					        });
					        CLSTraceData.callDepth--;
				        }

			        	traceOutput.addTraceResult({
				        	'type' 		: 'end',
				        	'txId' 		: txId,
				        	'time'		: Date.now(),
				        	'props' 	: [{'name':'httpstatus','value':response.statusCode},{'name':'sentresponseinjectedheader','value':sentInjHeader?sentInjHeader:uuid.v4()}],
				        	'exceptions' 	: traceUtil.safePopExceptionsStack(CLSTraceData)
				        });
				        CLSTraceData.callDepth--;
				    }

		        });

		        // handle when something falls over and response isn't going to be written. should have access to data in CLS here
		        response.addListener("close",function(){
		        	// don't close out the transaction twice
		        	if (CLSTraceData && !CLSTraceData.finished) {
		        		CLSTraceData.finished = true;
			        	// decrement our counters for tracking request concurrency
						currentInboundRequests--;

						while(CLSTraceData.callDepth > 1) {
				        	// close out outstanding interal calls now
					        traceOutput.addTraceResult({
					        	'type' 		: 'end',
					        	'txId' 		: txId,
					        	'time'		: Date.now(),
					        	'exceptions' 	: traceUtil.safePopExceptionsStack(CLSTraceData)
					        });
					        CLSTraceData.callDepth--;
				        }

			        	traceOutput.addTraceResult({
				        	'type' 		: 'end',
				        	'txId' 		: txId,
				        	'time'		: Date.now(),
				        	'props' 	: [{'name':'httpstatus','value':response.statusCode},{'name':'sentresponseinjectedheader','value':sentInjHeader?sentInjHeader:uuid.v4()}],
				        	'exceptions' 	: traceUtil.safePopExceptionsStack(CLSTraceData)
				        });
				        CLSTraceData.callDepth--;	
		        	}

		        });

		        traceOutput.addTraceResult({
		        	'type' 		: 'start',
		        	'txId' 		: txId,
		        	'category'	: 'Generic',
		        	'file'		: '',
		        	'method'	: (userHandler.name?userHandler.name:"(anonymous)"),
		        	'time'		: Date.now(),
		        	'props' 	: []
		        });
		        // increment open call count
		        CLSTraceData.callDepth++;
		        // add an array to track exceptions for this call
		        traceUtil.safePushExceptionsStack(CLSTraceData,[]);

		        // Now, call the original call back! (And CLS does the work of tracking across ASYNC calls)
		        userHandler(request, response);
		        // set the start and end properties
		        
		        traceOutput.addTraceResult({
		        	'type' 			: 'end',
		        	'txId' 			: txId,
		        	'time'			: Date.now(),
		        	'props' 		: [],
		        	'exceptions' 	: traceUtil.safePopExceptionsStack(CLSTraceData)
		        });
		        // decrement open call count
		        CLSTraceData.callDepth--;
		    });
		}
	});
};


// Hook receiving INCOMING requests.
function hookIncomingRequests(mod,protocol) {
	// Unhook createServer in case it is already hooked
	hooker.unhook(mod, 'createServer');

	// Preview any "request" events emitted by any server that gets created
	// Allows us to monitor incoming requests
	hooker.hook(mod, 'createServer', 
	 {
	 	'post': function() {
	 		if(arguments.length > 0 && arguments[0] instanceof mod.Server) {
	 			traceOutput.debug(protocol+".createServer", "wrapping server as EventEmitter to listen for request events");
	 			var server = arguments[0];
	 			traceEvent.wrapEmitter(server, wrapServerEmitter(protocol));
	 		}
	 	}
	 }
	);
};

// Hook STARTING the creation of an OUTGOING request
function hookOutgoingRequests(mod,protocol) {
	// Unhook http(s).request in case already hooked
	hooker.unhook(mod, 'request');

	// This is the start of the outbound request. [User calling http(s).request() or http.get()]
	// Tried to hook the ClientRequest constructor, but it looks like the 'http(s)' module might use it's own private reference to 
	hooker.hook(mod,'request', 
	    {
	        'pre': function outboundRequestWrapper() {

	        	// grab the original request function
	        	var origRequestFunc = hooker.orig(mod, 'request');

	            // First, make sure the arguments are an actual array.
	            var args = Array.prototype.slice.call(arguments);

	            // Are we short-circuited at this point
	            // NOTE: if we are not short-circuited at the time the outbound request is made, we will completely finish handling it,
				// even if we are short-circuited mid-way through the request.
	            var shortCircuited = traceConfig.isShortCircuited();

	            // only collect data if not short-circuited
	            if(!shortCircuited) {
		        	// increment our counters for tracking request concurrency/rate
					outboundRequestsReceived++;
					currentOutboundRequests++;

		        	// try to grab the URL and method from the arguments. 
		        	// URL may be passed as a string or in options object
		        	var URL = '';
		        	var httpmethod = 'GET';
		        	if(arguments.length>0) {
		        		if(traceUtil.isString(arguments[0])) {
		        			// got the URL as a string
		        			URL = arguments[0];
		        		} else if(arguments[0] instanceof Object) {
		        			var opts = arguments[0];
		        			// set httpmethod if specified in options
		        			httpmethod = opts.method ? opts.method : httpmethod;	
		        			// construct url from parts
		        			var host = (opts.hostname?opts.hostname:(opts.host?opts.host:''));	// preference given to hostname over host
		        			var port = (opts.port?':'+opts.port:'');
		        			var path = (opts.path?opts.path:'');
		        			URL = host + port + path;
		        		}
		        	}

					// generate outbound request txn id
					var outboundReqID = uuid.v4();
					// make sure we don't set receivedresponseinjectedheader more than once because it breaks stitching
					// could happen because of having a callback and listening to event EventEmitter
					var receivedresponseinjectedheaderAlreadyCaptured = false;
					// async id, assuming we're in a CLS context, this will get set using the current counter below
		            var asyncId = 0;

		            traceCLS.ifDataDo(protocol+".request",function(tracingData){
		            	// use the current iterator value as the request id and increment the iterator
		            	asyncId = tracingData.nextAsyncId;
		            	tracingData.nextAsyncId++;

			            // there is a callback specified
			            if(args.length>1 && args[1] && args[1] instanceof Function) {
			            	// wrap the callback
			            	traceOutput.debug(protocol+".request","wrapping user's callback");
			            	var origOutboundCb = args[1];
			            	var wrappedCb = function wrappedOutboundRequestCallback() {
			            		traceOutput.debug(protocol+".request","user's callback fired");
			            		var cbArgs = Array.prototype.slice.call(arguments);
								// decrement our counters for tracking request concurrency
								currentOutboundRequests--;

								// injected header in response
		            			var responseInjHeader;
		            			if(cbArgs && cbArgs.length > 0 && cbArgs[0] && cbArgs[0].headers) {
		            				responseInjHeader = getHeaderCaseInsensitive(cbArgs[0].headers,traceHeaderName);
		            			}

		            			var props = [
					        		{
			            				'name'		: 'async.id',
			            				'value'		: asyncId
			            			},
			           				{
			           					'name'		: 'eventtype',
			           					'value'		: 'response'
			           				}
				           		];

				           		if(responseInjHeader && !receivedresponseinjectedheaderAlreadyCaptured) {
												receivedresponseinjectedheaderAlreadyCaptured=true;
				           			props.push({'name' : 'receivedresponseinjectedheader', 'value' : responseInjHeader});
				           		}
								
								if(tracingData && !tracingData.finished) {
									traceOutput.addTraceResult({
							        	'type' 		: 'start',
							        	'txId' 		: tracingData.txId,
							        	'category'	: 'Generic',
							        	'file'		: '',
							        	'method'	: (origOutboundCb.name?origOutboundCb.name:"(anonymous)"),
							        	'time'		: Date.now(),
							        	'props' 	: props
							        });
							        // increment open call count
		        					tracingData.callDepth++;
							        // add an array to track exceptions for this call
							        traceUtil.safePushExceptionsStack(tracingData,[]);

			            			traceOutput.debug(protocol+".request.callback","set response event time for outbound request: "+outboundReqID);
			            		}
		            			// finally call the user's callback
		            			origOutboundCb.apply(this,cbArgs);
		            			if(tracingData && !tracingData.finished) {
			            			// set the callback end time
			        				traceOutput.addTraceResult({
							        	'type' 			: 'end',
							        	'txId' 			: tracingData.txId,
							        	'time'			: Date.now(),
							        	'props' 		: [],
							        	'exceptions' 	: traceUtil.safePopExceptionsStack(tracingData)
							        });
							        // decrement open call count
		        					tracingData.callDepth--;
			        			}

			            	}
			            	// use our wrapped callback
			            	args[1] = wrappedCb;
		            	}

		            	if(tracingData && !tracingData.finished) {
			            	traceOutput.addTraceResult({
					        	'type' 		: 'start',
					        	'txId' 		: tracingData.txId,
					        	'category'	: 'Web',
					        	'file'		: protocol,
					        	'method'	: 'request',
					        	'time'		: Date.now(),
					        	'props' 	: [
					        		{
			            				'name'		: 'sentrequestinjectedheader',
			            				'value'		: outboundReqID
			            			},
			            			{
			            				'name'		: 'async.id',
			            				'value'		: asyncId
			            			},
			            			{
			            				'name'		: 'async.category',
			            				'value'		: 'Remote'
			            			},
			            			{
			            				'name'		: 'urloutbound',
			            				'value'		: URL
			            			},
			           				{
			           					'name'		: 'http.method',
			           					'value'		: httpmethod
			           				}
			           			]
					        });
					        // increment open call count
		        			tracingData.callDepth++;
					        // add an array to track exceptions for this call
							traceUtil.safePushExceptionsStack(tracingData,[]);
					        traceOutput.debug(protocol+".request", "updated trace with new outbound request: "+outboundReqID);
					    }
		            });
		        }

	            // actually construct the request and grab the return value, 
	            // which should be a http(s).ClientRequest object (which is also an EventEmitter)
	            // need to do this regardless of whether we are short-circuited or not
	        	var clientRequestObject = origRequestFunc.apply(this,args);	  

	        	// only collect data if not short-circuited
	            if(!shortCircuited) {
	    			traceCLS.ifDataDo(protocol+".request",function(tracingData){

	    				if(tracingData && !tracingData.finished) {
					        traceOutput.addTraceResult({
					        	'type' 			: 'end',
					        	'txId' 			: tracingData.txId,
					        	'time'			: Date.now(),
					        	'props' 		: [],
					        	'exceptions' 	: traceUtil.safePopExceptionsStack(tracingData)
					        });
					        // decrement open call count
		        			tracingData.callDepth--;
					    }

		            	// set header for tracing id on outgoing request
		            	clientRequestObject.setHeader(traceHeaderName,outboundReqID);
		    			traceOutput.debug(protocol+".request","set outbound header "+traceHeaderName+": "+outboundReqID);

		    			var outboundReqComplete = false;

	    				traceOutput.debug(protocol+".request","wrapping the ClientRequest object as an EventEmitter");
		            	traceCLS.bindEmitterWithHooks(clientRequestObject,
		            		function clientRequestEmitterPre(eventType,name,args){

		            			if(tracingData && !tracingData.finished) {
			            			traceOutput.addTraceResult({
							        	'type' 		: 'start',
							        	'txId' 		: tracingData.txId,
							        	'category'	: 'Generic',
							        	'file'		: '',
							        	'method'	: (name?name:"(anonymous)"),
							        	'time'		: Date.now(),
							        	'props' 	: [
							        		{
					            				'name'		: 'async.id',
					            				'value'		: asyncId
					            			},
					           				{
					           					'name'		: 'eventtype',
					           					'value'		: eventType
					           				}
					           			]
							        });
							        // increment open call count
		        					tracingData.callDepth++;
							        // add an array to track exceptions for this call
									traceUtil.safePushExceptionsStack(tracingData,[]);
								}

			            		if(eventType=='response'){
			            			if(args && args.length > 0) {
			            				// injected header in response
		            					var responseInjHeader;
			            				if(args[0] && args[0].headers) {
			            					responseInjHeader = getHeaderCaseInsensitive(args[0].headers,traceHeaderName);
			            				}

			            				// bind the response object which is an eventEmitter that's a stream
			            				traceCLS.bindEmitterWithHooks(args[0],
			            					function clientRequestResponseEmitterPre(respEventType,respName,respArgs){

			            						var props = [
									        		{
							            				'name'		: 'async.id',
							            				'value'		: asyncId
							            			},
							           				{
							           					'name'		: 'eventtype',
							           					'value'		: respEventType
							           				}
								           		];

								           		if (responseInjHeader && !receivedresponseinjectedheaderAlreadyCaptured) {
																receivedresponseinjectedheaderAlreadyCaptured = true;
								           			props.push({'name' : 'receivedresponseinjectedheader', 'value' : responseInjHeader});
								           		}

								           		if(tracingData && !tracingData.finished) {
				            						traceOutput.addTraceResult({
											        	'type' 		: 'start',
											        	'txId' 		: tracingData.txId,
											        	'category'	: 'Generic',
											        	'file'		: '',
											        	'method'	: (respName?respName:"(anonymous)"),
											        	'time'		: Date.now(),
											        	'props' 	: props
											        });
											        // increment open call count
		        									tracingData.callDepth++;
											        // add an array to track exceptions for this call
													traceUtil.safePushExceptionsStack(tracingData,[]);
												}

												if(respEventType=='error') {
							            			if(respArgs.length>0 && respArgs[0] instanceof Error) {
							            				var respErrStr = (respArgs[0].name?respArgs[0].name+": ":"(unknown)")+(respArgs[0].message?respArgs[0].message:"");
							            				traceUtil.safeAddExceptionToExceptionsStack(tracingData,respErrStr);
							            			}
							            		}

				            					return null;
				            				},
				            				function clientRequestResponseEmitterPost(cb,userResult){
				            					if(tracingData && !tracingData.finished) {
					            					traceOutput.addTraceResult({
											        	'type' 		: 'end',
											        	'txId' 		: tracingData.txId,
											        	'time'		: Date.now(),
											        	'props' 	: [],
											        	'exceptions' 	: traceUtil.safePopExceptionsStack(tracingData)
											        });
											        // decrement open call count
		        									tracingData.callDepth--;
					            				}
				            				}
				            			);
			            			}
			            		} else if(eventType=='end' || eventType=='abort' || eventType=='close') {
			            			if(!outboundReqComplete) {
			            				// decrement our counters for tracking request concurrency
										currentOutboundRequests--;
										outboundReqComplete=true;
			            			}
			            		} else if(eventType=='error') {
			            			if(!outboundReqComplete) {
			            				// decrement our counters for tracking request concurrency
										currentOutboundRequests--;
										outboundReqComplete=true;
			            			}
			            			if(args.length>0 && args[0] instanceof Error) {
			            				var errStr = (args[0].name?args[0].name+": ":"(unknown)")+(args[0].message?args[0].message:"");
			            				traceUtil.safeAddExceptionToExceptionsStack(tracingData,errStr);
			            			}
			            		}
		    					return null;
		            		},
		            		function clientRequestEmitterPost(cb,userResult){
		            			if(tracingData && !tracingData.finished) {
			            			traceOutput.addTraceResult({
							        	'type' 			: 'end',
							        	'txId' 			: tracingData.txId,
							        	'time'			: Date.now(),
							        	'props' 		: [],
							        	'exceptions' 	: traceUtil.safePopExceptionsStack(tracingData)
							        });
							        // decrement open call count
		        					tracingData.callDepth--;
			            		}
		    				}
		            	);
	            	});
				}

	            // return the actual ClientRequest, while telling 'hooker' not to call request itself ('preempt'),
		        // because we already just did.
		        // do this regardless of whether we're short-circuited or not
		        return hooker.preempt(clientRequestObject);
	        },
	        'passName': false
	    }
	);
};

// -----------------------------
// External Functions
// -----------------------------
var instrumentHttp = exports.instrumentHttp = function() {
	hookIncomingRequests(http,"http");
	hookIncomingRequests(https,"https");
	hookOutgoingRequests(http,"http");
	hookOutgoingRequests(https,"https");
};

var getTotalInboundRequestCount = exports.getTotalInboundRequestCount = function() {
	return inboundRequestsReceived;
};

var getCurrentInboundRequestCount = exports.getCurrentInboundRequestCount = function() {
	return currentInboundRequests;
};

var getTotalOutboundRequestCount = exports.getTotalOutboundRequestCount = function() {
	return outboundRequestsReceived;
};

var getCurrentOutboundRequestCount = exports.getCurrentOutboundRequestCount = function() {
	return currentOutboundRequests;
};

var clearRequestMetrics = exports.clearRequestMetrics = function() {
	inboundRequestsReceived = 0;
	outboundRequestsReceived = 0;
	// don't want to clear current to zero because they haven't finished yet.
	// we would end up with negative values for current once they finish
};