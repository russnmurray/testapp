/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// MySql Instrumentation Module
// *****************************

// required modules
var hooker = require('hooker'),
	uuid = require('uuid'),
	path = require('path'),
	traceUtil = require('./trace-util'),
	traceCLS = require('./trace-cls'),
	traceConfig = require('./trace-config'),
	traceOutput = require('./trace-output-api'),
	traceEvent = require('./trace-event');

// -----------------------------
// Internal Functions
// -----------------------------

function hookMysqlQuery(mysql, Connection) {

	// Unhook Connection.query in case already hooked
	hooker.unhook(Connection, 'createQuery');

	// This is the start of the outbound sql query.
	hooker.hook(Connection,'createQuery', 
	    {
	        'pre': function sqlQueryWrapper() {

	        	// grab the original query function
	        	var origQueryFunc = hooker.orig(Connection,'createQuery');

	            // First, make sure the arguments are an actual array.
	            var args = Array.prototype.slice.call(arguments);

	            // Are we short-circuited at this point
	            // NOTE: if we are not short-circuited at the time the query is created, we will completely finish handling it,
				// even if we are short-circuited mid-way through the request.
	            var shortCircuited = traceConfig.isShortCircuited();

	            // only collect data if not short-circuited
	            if(!shortCircuited) {
	            	// outbound request txn id, assuming we're in a CLS context, this will get set using the current counter below
	            	var sqlReqID = 0;
	            	
		            var callbackIdx = traceUtil.findCallbackArgumentIndex(args),
		            	callbackProvided = (callbackIdx >= 0);

	            	traceCLS.ifDataDo("mysql.Connection.query",function(tracingData){
			        	// use the current iterator value as the request id and increment the iterator
		            	sqlReqID = tracingData.nextAsyncId;
		            	tracingData.nextAsyncId++;

			            // was a callback specified as part of args?
			            if(callbackProvided) {
			            	// If so, need to wrap it and replace it w/ our wrapped version in args
			            	// when calling original query func
			            	traceOutput.debug("mysql.Connection.query","wrapping user's callback");
			            	var userCallback = args[callbackIdx];
			            	var wrappedCallback = function () {
								// First, make sure the arguments are an actual array.
								var args = Array.prototype.slice.call(arguments);

								if(tracingData && !tracingData.finished) {
			            			traceOutput.addTraceResult({
							        	'type' 		: 'start',
							        	'txId' 		: tracingData.txId,
							        	'category'	: 'Generic',
							        	'file'		: '',
							        	'method'	: (userCallback.name?userCallback.name:"(anonymous)"),
							        	'time'		: Date.now(),
							        	'props' 	: [
							        		{
					            				'name'		: 'async.id',
					            				'value'		: sqlReqID
					            			},
					           				{
					           					'name'		: 'eventtype',
					           					'value'		: 'response'
					           				}
							        	]
							        });
							        // increment open call count
		        					tracingData.callDepth++;
							        // add an array to track exceptions for this call
									traceUtil.safePushExceptionsStack(tracingData,[]);
								}

								if(args.length>0 && args[0] instanceof Error) {
									// this is an error
									var errStr = (args[0].name?args[0].name+": ":"(unknown)")+(args[0].message?args[0].message:"");
									traceUtil.safeAddExceptionToExceptionsStack(tracingData,errStr);
								}
								
						        // call the actual handler (the user's handler).
						         // return handler.apply(this, args);
						        // ORIG
						        var result = userCallback.apply(this, args);
						        
						        if(tracingData && !tracingData.finished) {
							        traceOutput.addTraceResult({
							        	'type' 			: 'end',
							        	'txId' 			: tracingData.txId,
							        	'time'			: Date.now(),
							        	'props' 		: [],
							        	'exceptions' 	: traceUtil.safePopExceptionsStack(tracingData)
							        });
							        // decrement open call count
		        					tracingData.callDepth--;
							    }

		        				return result;
						  	};

			            	args[callbackIdx]=wrappedCallback;
		            	}
		        	});
		        }

		        // take a timestamp
		        var beforeCreateReqTimestamp = Date.now();

	            // actually construct the query and grab the return value, 
	            // which should be a mysql.Query object (which is also an EventEmitter)
	            // need to do this regardless of whether we are short-circuited or not
	        	var queryObject = origQueryFunc.apply(this,args);

	        	// take a timestamp
		        var afterCreateReqTimestamp = Date.now();  

	        	// only collect data if not short-circuited
	            if(!shortCircuited) {
		            if(queryObject) {

		    			// see if there is tracing data in the context of the current (inbound) request
		    			traceCLS.ifDataDo("mysql.Connection.query",function(tracingData){

		    				if(tracingData && !tracingData.finished) {
		    					traceOutput.addTraceResult({
						        	'type' 		: 'start',
						        	'txId' 		: tracingData.txId,
						        	'category'	: 'MySQL',
						        	'file'		: 'mysql.Connection',
						        	'method'	: 'query',
						        	'time'		: beforeCreateReqTimestamp,
						        	'props' 	: [
						        		{
				            				'name'		: 'async.id',
				            				'value'		: sqlReqID
				            			},
				            			{
				            				'name'		: 'async.category',
				            				'value'		: 'MySQL'
				            			},
				            			{
				            				'name'		: 'sql',
				            				'value'		: (queryObject.sql?queryObject.sql.toString():'')
				            			},
				            			{
				            				'name'		: 'sqlbindvar',
				            				'value'		: (queryObject.values?queryObject.values.toString():'')
				            			}
						        	]
						        });
						        // increment open call count
		        				tracingData.callDepth++;
						        // add an array to track exceptions for this call
								traceUtil.safePushExceptionsStack(tracingData,[]);
							}

							if(tracingData && !tracingData.finished) {
						        traceOutput.addTraceResult({
						        	'type' 			: 'end',
						        	'txId' 			: tracingData.txId,
						        	'time'			: afterCreateReqTimestamp,
						        	'props' 		: [],
						        	'exceptions' 	: traceUtil.safePopExceptionsStack(tracingData)
						        });
						        // decrement open call count
		        				tracingData.callDepth--;
						    }

		            		traceOutput.debug("mysql.Connection.query","updated trace with new query: "+sqlReqID);

		            		// Is this a streaming request? Only can have this if a callback wasn't provided
			            	// If there was a callback, we don't want to wrap this.
			            	if (!callbackProvided) {
				            	traceOutput.debug("mysql.Connection.query","wrapping the Query object as an EventEmitter");
				            	traceCLS.bindEmitterWithHooks(queryObject,
					            	function mySqlQueryEmitterPre(eventType,name,args){

					            		if(tracingData && !tracingData.finished) {
						            		traceOutput.addTraceResult({
									        	'type' 		: 'start',
									        	'txId' 		: tracingData.txId,
									        	'category'	: 'Generic',
									        	'file'		: '',
									        	'method'	: (name?name:"(anonymous)"),
									        	'time'		: Date.now(),
									        	'props' 	: [
									        		{
							            				'name'		: 'async.id',
							            				'value'		: sqlReqID
							            			},
							           				{
							           					'name'		: 'eventtype',
							           					'value'		: eventType
							           				}
									        	]
									        });
									        // increment open call count
		        							tracingData.callDepth++;
									        // add an array to track exceptions for this call
											traceUtil.safePushExceptionsStack(tracingData,[]);
										}

										if(eventType=='error') {
					            			if(args.length>0 && args[0] instanceof Error) {
					            				var errStr = (args[0].name?args[0].name+": ":"(unknown)")+(args[0].message?args[0].message:"");
					            				traceUtil.safeAddExceptionToExceptionsStack(tracingData,errStr);
					            			}
					            		}

					            		return null;
					            	},
					            	function mySqlQueryEmitterPost(cb,userResult){
					            		if(tracingData && !tracingData.finished) {
					    					traceOutput.addTraceResult({
									        	'type' 		: 'end',
									        	'txId' 		: tracingData.txId,
									        	'time'		: Date.now(),
									        	'props' 	: [],
									        	'exceptions' 	: traceUtil.safePopExceptionsStack(tracingData)
									        });
									        // decrement open call count
		        							tracingData.callDepth--;
					    				}
				    				}
			    				);
			            	}
		    			});
		            	
		            } 
		        }

	            // return the actual ClientRequest, while telling 'hooker' not to call request itself ('preempt'),
		        // because we already just did.
		        // do this regardless of whether we're short-circuited or not
		        return hooker.preempt(queryObject);
	        },
	        'passName': false
	    }
	);
};

// -----------------------------
// External Functions
// -----------------------------
var instrumentMySql = exports.instrumentMySql = function(requiredMod) {
	var mysql = require(requiredMod),
		Connection = require(requiredMod+path.sep+'lib'+path.sep+'Connection');
	hookMysqlQuery(mysql,Connection);
};