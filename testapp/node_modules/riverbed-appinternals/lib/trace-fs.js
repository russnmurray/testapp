/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// Filesystem stats Module
// *****************************

// required modules
var traceConfig = require('./trace-config'),
	//traceCLS = require('./trace-cls'),
	fs = require('fs'),
	util = require('util'),
	traceUtil = require('./trace-util'),
	hooker = require('hooker');

function resetStats() {
	return {
		readBytes:0,
		writtenBytes:0
	};
};

var stats = resetStats();

// -----------------------------
// Internal Functions
// -----------------------------

// for info on signatures of functions and handling for backwards compatibility etc see:
// https://github.com/joyent/node/blob/master/lib/fs.js#L509

// wraps a call back for fs.binding.read
// all the wrapper does is find out how many bytes were read before passing off to the original callback
function wrapOriginalReadCallback(origCb, isLegacy) {
	return function() {

		// First, make sure the arguments are an actual array.
		var args = Array.prototype.slice.call(arguments);

		// Only collect data if not currently short-circuited
		if(!traceConfig.isShortCircuited()) {
			if(isLegacy) {
				// number of bytes should be second argument
				if(args.length > 2 && args[2]) {
					stats.readBytes += args[2];
				}
			} else {
				// number of bytes should be second argument
				if(args.length > 1 && args[1]) {
					stats.readBytes += args[1];
				}
			}

			// Could try to use this for capturing errors, but doesn't seem worth it.
			// Lot of things would be missed since things like readFile don't actually call read
			// if errors occur e.g. at open time.
			// Seems better to hold off for a more complete pass at error handling.
			//
			// if(args.length>0 && args[0] instanceof Error) {
			// 	// this is an error
			// 	traceCLS.ifDataDo("fs.read",function(tracingData){
			// 		var errStr = (args[0].name?args[0].name+": ":"(unknown)")+(args[0].message?args[0].message:"");
			//      traceUtil.safeAddExceptionToExceptionsStack(tracingData,errStr);
			// 	});
			// }
		}

		return origCb.apply(this,args);
	};
};

// wraps a call back for fs.binding.write
// all the wrapper does is find out how many bytes were written before passing off to the original callback
function wrapOriginalWriteCallback(origCb) {
	return function() {

		// First, make sure the arguments are an actual array.
		var args = Array.prototype.slice.call(arguments);

		// Only collect data if not currently short-circuited
		if(!traceConfig.isShortCircuited()) {
			// number of bytes should be second argument
			if(args.length > 1 && args[1]) {
				stats.writtenBytes += args[1];
			}
		}

		// Could try to use this for capturing errors, but doesn't seem worth it.
		// Lot of things would be missed since things like writeFile don't actually call write
		// if errors occur e.g. at open time.
		//	Seems better to hold off for a more complete pass at error handling.
		//
		// if(args.length>0 && args[0] instanceof Error) {
		// 	// this is an error
		// 	traceCLS.ifDataDo("fs.write",function(tracingData){
		// 		var errStr = (args[0].name?args[0].name+": ":"(unknown)")+(args[0].message?args[0].message:"");
		//      traceUtil.safeAddExceptionToExceptionsStack(tracingData,errStr);
		// 	});
		// }

		return origCb.apply(this,args);
	};
};

function hookRead() {
	// Unhook read in case it is already hooked
	hooker.unhook(fs, 'read');

	// Try to wrap the callback passed into fs.read.
	// There's some backwards compatibility handling in fs.read, so need to detect which arg is the callback
	// see: 
	// https://github.com/joyent/node/blob/master/lib/fs.js#L510
	// and
	// https://github.com/joyent/node/blob/master/lib/fs.js#L512
	hooker.hook(fs, 'read', 
	 {
	   'pre': function() {

	   		// First, make sure the arguments are an actual array.
			var args = Array.prototype.slice.call(arguments);

			if(args.length > 1 && !traceUtil.isBuffer(args[1])) {
				// backwards compatibility case
				if(args.length > 4 && args[4] instanceof Function) {
					// found the callback to wrap
					args[4] = wrapOriginalReadCallback(args[4],true);
				} else {
					// no callback supplied
					args[4] = wrapOriginalReadCallback(function(){},true);
				}
			} 
			// normal case
			else if(args.length > 5 && args[5] instanceof Function) {
				// found the callback to wrap
				args[5] = wrapOriginalReadCallback(args[5],false);
			} else {
				// no callback supplied
				args[5] = wrapOriginalReadCallback(function(){},false);
			}

			var origRead = hooker.orig(fs, 'read');
			var result = origRead.apply(this,args);
			
			//tell 'hooker' not to call read itself ('preempt'),
		    // because we already just did.
		    return hooker.preempt(result);

		},
	   'passName': false
	 }
	);
};

function hookReadSync() {
	// Unhook readSync in case it is already hooked
	hooker.unhook(fs, 'readSync');

	// Capture the number of bytes returned
	// Need to detect format for legacy option
	hooker.hook(fs, 'readSync', 
	 {
	   'post': function() {
	   		// First, make sure the arguments are an actual array.
			var args = Array.prototype.slice.call(arguments);

			// Only collect data if not currently short-circuited
			if(!traceConfig.isShortCircuited()) {
				var result = 0;

				if(args.length > 0) {
					if(util.isArray(args[0])) {
						// result is an array of [String,byte length]
						// https://github.com/joyent/node/blob/master/lib/fs.js#L563
						result = args[0][1];
					} else {
						// result is length
						result = args[0];
					}
				}

				stats.readBytes += result;
			}
		},
	   'passName': false
	 }
	);
};

function hookWrite() {
	// Unhook write in case it is already hooked
	hooker.unhook(fs, 'write');

	// Try to wrap the callback passed into fs.write.
	// Callback should always be last arg
	// see: 
	// https://github.com/joyent/node/blob/master/lib/fs.js#L567
	hooker.hook(fs, 'write', 
	 {
	   'pre': function() {

	   		// First, make sure the arguments are an actual array.
			var args = Array.prototype.slice.call(arguments);

			if(args.length > 1 && args[args.length-1] instanceof Function) {
				// found the callback to wrap
				args[args.length-1] = wrapOriginalWriteCallback(args[args.length-1]);
			}

			var origWrite = hooker.orig(fs, 'write');
			var result = origWrite.apply(this,args);
			
			//tell 'hooker' not to call write itself ('preempt'),
		    // because we already just did.
		    return hooker.preempt(result);

		},
	   'passName': false
	 }
	);
};

// see https://github.com/joyent/node/blob/master/lib/fs.js#L611
function hookWriteSync() {
	// Unhook writeSync in case it is already hooked
	hooker.unhook(fs, 'writeSync');

	// Try to capture number of bytes written
	hooker.hook(fs, 'writeSync', 
	 {
	   'post': function() {

	   		// Only collect data if not currently short-circuited
			if(!traceConfig.isShortCircuited()) {
		   		// First, make sure the arguments are an actual array.
				var args = Array.prototype.slice.call(arguments);

				// bytes is first/only arg
				if(args.length > 0) {
					stats.writtenBytes += args[0];
				}
			}
		},
	   'passName': false
	 }
	);
};


// -----------------------------
// External Functions
// -----------------------------

var getBytesRead = exports.getBytesRead = function() {
	return stats.readBytes;
};

var getBytesWritten = exports.getBytesWritten = function() {
	return stats.writtenBytes;
};

var clearResults = exports.clearResults = function() {
	stats = resetStats();
};

exports.instrumentFs = function(){
	hookRead();
	hookReadSync();
	hookWrite();
	hookWriteSync();
};