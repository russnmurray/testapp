/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */

"use strict";

// *****************************
// Module Detection Module
// *****************************

// NOTE: intentionally not checking for short-circuiting here.
// We still want to instrument when the module is required
// even if we are short-circuited.
// It's up to the instrumentation sub-module to ensure that
// it doesn't do anything when short-circuited.
// In the case where we're un-instremented, the main instrumentation file
// will never call init on this module-detection module,
// so we don't need to do anything to handle that case.

// required modules
var traceOutput = require('./trace-output-api'),
	traceConfig = require('./trace-config'),
	traceUtil = require('./trace-util'),
	path = require('path'),
	hooker = require('hooker'),
	mod = require('module');

// Internal variables
var instrumented = {};

// -----------------------------
// Internal Functions
// -----------------------------

function endsWith(str, toMatch) {
	if(!str || !traceUtil.isString(str) || !toMatch || !traceUtil.isString(toMatch) || toMatch.length > str.length){
		return false;
	}

	return (str.substring(str.length-toMatch.length,str.length) == toMatch);
}

function matchedModulePath(requiredName,lookingFor){
	// no match if there's something bad about either arg
	if(!requiredName || !traceUtil.isString(requiredName) || !lookingFor || !traceUtil.isString(lookingFor)){
		return null;
	}

	try {
		// attempt to parse the path for the request module and get the name
		// NOTE: these seem to either be just a name (built-in module) or else and absolute path
		// so we don't have to worry about relative paths
		var parsedPath = traceUtil.pathParse(requiredName);
		if(parsedPath.name == lookingFor) {
			// basic case, name matches
			return parsedPath.dir;
		} else if(parsedPath.base == "index.js" && (parsedPath.dir == lookingFor || endsWith(parsedPath.dir,path.sep+lookingFor))) {
			// it's the index file for the module. need to find module name from the path
			return parsedPath.dir;
		}
	} catch(err){
		// do nothing, let default return of null happen, but don't let the exception bubble up
	}

	return null;
};

// -----------------------------
// External Functions
// -----------------------------

exports.init = function(){
	hooker.unhook(mod,"_resolveFilename");
	hooker.hook(mod,"_resolveFilename",{
		'post':function hookResolveFilename(){
			if(arguments && arguments.length > 0) {

				var moduleRequired = arguments[0];
				var mysqlMatch = matchedModulePath(moduleRequired,"mysql");
				var mongodbMatch = matchedModulePath(moduleRequired,"mongodb");
				var mongodbCoreMatch = matchedModulePath(moduleRequired,"mongodb-core");
				var mongooseMatch = matchedModulePath(moduleRequired,"mongoose");
				var mqueryMatch = matchedModulePath(moduleRequired,"mquery");

				if(mysqlMatch != null) {
					if (!instrumented[mysqlMatch]) {
						traceOutput.info("module-detection.hookResolveFilename","Starting mysql instrumentation for: "+mysqlMatch+path.sep+"mysql");
						// need to set this to true BEFORE loading instrumentation
						// otherwise mysql instrumenation will also call require("mysql")
						// and we end up in an infinite recursion
						instrumented[mysqlMatch] = true;
						require('./trace-mysql').instrumentMySql(mysqlMatch);
					}
				} else if (mongodbMatch != null) {
					if (!instrumented[mongodbMatch]) {
						traceOutput.info("module-detection.hookResolveFilename","Starting mongodb instrumentation for: "+mongodbMatch);
						// need to set this to true BEFORE loading instrumentation
						// otherwise mysql instrumenation will also call require("mongodb")
						// and we end up in an infinite recursion
						instrumented[mongodbMatch] = true;
						require('./trace-mongodb').instrumentMongo(mongodbMatch);
					}
				} else if (mongodbCoreMatch != null) {
					if (!instrumented[mongodbCoreMatch]) {
						traceOutput.info("module-detection.hookResolveFilename","Starting mongodb-core instrumentation for: "+mongodbCoreMatch+path.sep+"mongodb-core");
						// need to set this to true BEFORE loading instrumentation
						// otherwise mysql instrumenation will also call require("mongodb-core")
						// and we end up in an infinite recursion
						instrumented[mongodbCoreMatch] = true;
						require('./trace-mongodb').instrumentCoreMongo(mongodbCoreMatch);
					}
				} else if (mongooseMatch != null) {
					if (!instrumented[mongooseMatch]) {
						traceOutput.info("module-detection.hookResolveFilename","Starting mongoose instrumentation for: "+mongooseMatch+path.sep+"mongoose");
						// need to set this to true BEFORE loading instrumentation
						// otherwise mysql instrumenation will also call require("mongoose")
						// and we end up in an infinite recursion
						instrumented[mongooseMatch] = true;
						require('./trace-mongodb').instrumentMongoose(mongooseMatch);
					}
				} else if (mqueryMatch != null) {
					if (!instrumented[mqueryMatch]) {
						traceOutput.info("module-detection.hookResolveFilename","Starting mquery instrumentation for: "+mqueryMatch+path.sep+"mquery");
						// need to set this to true BEFORE loading instrumentation
						// otherwise mysql instrumenation will also call require("mquery")
						// and we end up in an infinite recursion
						instrumented[mqueryMatch] = true;
						require('./trace-mongodb').instrumentMquery(mqueryMatch);
					}
				} else {
					var engineMatch = matchedModulePath(moduleRequired,"engine.io");
					if(engineMatch != null) {
						if (!instrumented[engineMatch]) {
							traceOutput.info("module-detection.hookResolveFilename","Starting socket.io instrumentation for: "+engineMatch+path.sep+"engine.io");
							// need to set this to true BEFORE loading instrumentation
							// otherwise mysql instrumenation will also call require("socket.io")
							// and we end up in an infinite recursion
							instrumented[engineMatch] = true;
							require('./trace-socketio').instrumentSocketIO(engineMatch);
							require('./trace-env').enableSocketIoCollection(true);
						}
					} else {
						var gcStatsMatch = matchedModulePath(moduleRequired,"gc-stats");
						if(gcStatsMatch != null && traceConfig.isAllowNativeDependencies()) {
							// using constant string 'gc-stats'
							// this isn't really instrumentation like mysql or socket.io
							// where we want to do something for each occurence.
							// we are happy to use the first occurrence of gc-stats that is
							// loaded in order to collect stats. we can ignore any subsequent
							// load of gc-stats
							if(!instrumented['gc-stats']) {
								traceOutput.info("module-detection.hookResolveFilename","Starting instrumentation for GC stats using: "+gcStatsMatch+path.sep+"gc-stats");
								// need to set this to true BEFORE loading instrumentation
								// otherwise trace-env instrumenation will also call require("gc-stats")
								// and we end up in an infinite recursion
								instrumented['gc-stats'] = true;
								require('./trace-env').instrumentGC(gcStatsMatch);
							}
						} else {
							var profilerMatch = matchedModulePath(moduleRequired,"v8-profiler");
							if(profilerMatch != null && traceConfig.isAllowNativeDependencies()) {
								// using constant string 'v8-profiler'
								// this isn't really instrumentation like mysql or socket.io
								// where we want to do something for each occurence.
								// we are happy to use the first occurrence of v8-profiler that is
								// loaded in order to support profiling. we can ignore any subsequent
								// load of v8-profiler
								if(!instrumented['v8-profiler']) {
									traceOutput.info("module-detection.hookResolveFilename","Starting support for profiling using: "+profilerMatch+path.sep+"v8-profiler");
									// need to set this to true BEFORE loading instrumentation
									// otherwise trace-profile instrumenation will also call require("v8-profiler")
									// and we end up in an infinite recursion
									instrumented['v8-profiler'] = true;
									// actually enable the support
									require('./trace-profile').enableProfilerSupport(profilerMatch);
									// also let the input API know that this is now supported
									require('./trace-input-api').addFeatureSupport('v8-profiler');
								}
							}
						}
					}
				}

				// default case we don't want to do anything here. user loaded some module we don't care about.
			}
		}
	});
};

