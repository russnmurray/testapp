/* ****************************
** Copyright (c) 2017        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */
/*******************************************************************************
  Changes:

  - Date   -  UID  --------------------- Description ---------------------
  09/29/2016  ecl  BUG268560: Account for multi-byte characters when getting
                   the number of bytes in a string.
  09/26/2017  ecl  BUG290337: Add "collect" as an override alternative to "instrument.bypass".
 ******************************************************************************/

"use strict";

var logger = require('../trace-output-tcp'),
	transportHdr = require('../protocol/transportHeader'),
	msgHeader = require('../protocol/messageHeader'),
	msgUtil = require('../protocol/util'),
	msgcon = require('../protocol/constants'),
	traceConfig = require('../trace-config');

//-----------------------------
//Internal Constants
//-----------------------------

//-----------------------------
//Internal Variables
//-----------------------------

var logLocation = 'configMsgs',
	lastModified 	= Date.now();

//-----------------------------
//External Functions
//-----------------------------

var decodeConfigChange = exports.decodeConfigChange = function (buffer, transportHeader) {

	// go past the opcode
	var offset = 4;

	logger.logDebug(logLocation+'.decodeConfigChange', 'buf len:'+buffer.length);
	try {
		var daDebug = buffer[offset++];
		logger.logDebug(logLocation+'.decodeConfigChange', 'daDebug:'+daDebug);

		var instrumentationState = buffer[offset++];

		var overrides = msgUtil.readMsgString(buffer, offset, transportHeader.encoding);
		offset += 4 + msgUtil.getStringBytes(overrides);

		var configFile = msgUtil.readMsgString(buffer, offset, transportHeader.encoding);
		offset += 4 + msgUtil.getStringBytes(configFile);
		logger.logDebug(logLocation+'.decodeConfigChange', 'configFile size:'+msgUtil.getStringBytes(configFile));

		// default value if no config file
		var logLevel = daDebug ? traceConfig.LOGGING_LEVELS.DEBUG : traceConfig.LOGGING_LEVELS.INFO;

		switch(instrumentationState) {
		case msgcon.ConfigChgInstrumentationState.NotInstrumented:
			// turn off instrumentation; short circuit the collection as instrumentation will not be
			// disabled until there is a restart
			logger.logDebug(logLocation+'.decodeConfigChange', 'NOT INSTRUMENTED - Using defaults');
			traceConfig.setShouldInstrument(false);
			traceConfig.setShortCircuited(true);
			break;
		case msgcon.ConfigChgInstrumentationState.Instrumented:

			// we are instrumented - so we should have a config file and overrides
			//TODO what if we don't
			if (configFile.length != 0) {
				var jsonConfig = JSON.parse(configFile);
				//logger.logDebug(logLocation+'.decodeConfigChange', ('json config:'+JSON.stringify(jsonConfig)));

				if (jsonConfig.configuration["logging.verbose"] != undefined) {
					logLevel = jsonConfig.configuration["logging.verbose"] ? traceConfig.LOGGING_LEVELS.DEBUG : traceConfig.LOGGING_LEVELS.INFO;
				}
				if (jsonConfig.configuration["metric.report.http.headersbrowserviewcookies"] != undefined) {
					traceConfig.setSendEUEResponseHeaders(jsonConfig.configuration["metric.report.http.headersbrowserviewcookies"]);
				}
			}

			if (overrides.length != 0) {
				var jsonOverrides = JSON.parse(overrides);
				//logger.logDebug(logLocation+'.decodeConfigChange', ('json overrides:'+JSON.stringify(overrides)));
				logger.logDebug(logLocation+'.decodeConfigChange', ('json overrides:'+JSON.stringify(overrides)));

				// To match the UI and make it easier to configure, allow the use of "collect=true"
				// instead of "instrument.bypass=false".  If "collect" and "instrument.bypass" are
				// set, use "collect" since this is the documented way to override this setting.
				if (jsonOverrides["collect"] != undefined) {
					traceConfig.setShortCircuited(!jsonOverrides["collect"]);
				} else if (jsonOverrides["instrument.bypass"] != undefined) {
					traceConfig.setShortCircuited(jsonOverrides["instrument.bypass"]);
				}
			}
			traceConfig.setShouldInstrument(true);
			break;
		case msgcon.ConfigChgInstrumentationState.Missing:
			logger.logDebug(logLocation+'.decodeConfigChange', 'Instrumentation State is MISSING - Using defaults');
			// This is sent when the node instr comes up the very first time and the app is unknown to the Node DA
			// So use our defaults for instrumented, bypassed, and sendEueRespHdrs if no current state
			// The NodeDA will also send 'MISSING' when an error occurs (like a user deletes a file they shouldn't delete)
			// and we shouldn't respond to that (e.g. setting instr to ON when it was OFF because ON is out default)
			break;
		default:
			logWarn(logLocation+'.processRequest', 'Received an unsupported request:'+opcode);
			// use defaults for instrumented, bypassed, and sendEueRespHdrs
		}

		traceConfig.setLogLevel(logLevel);
		logger.logDebug(logLocation+'.decodeConfigChange', 'instrumented:'+traceConfig.shouldInstrument());
		logger.logDebug(logLocation+'.decodeConfigChange', 'bypassed:'+traceConfig.isShortCircuited());
		logger.logDebug(logLocation+'.decodeConfigChange', 'sendEueRespHdrs:'+traceConfig.isSendEUEResponseHeaders());
		logger.logDebug(logLocation+'.decodeConfigChange', 'log level:'+traceConfig.getLogLevel());

	} catch (err) {

		// TODO this catches any error but didn't log anything ?????
		logger.logDebug(logLocation+'.decodeConfigChange', 'ERROR:'+err.message);
		// TODO not sure whether we should do this - probably depends on whether we got a file or not, whether this is first time or not
		//traceConfig.setShouldInstrument(true);
		//traceConfig.setShortCircuited(true);
		//logLevel = traceConfig.getLogLevel(); // Current log level
	}
	finally {
	}
	//DEBUG TO CIRCUMVENT CONFIG CHANGE
	//traceConfig.setShortCircuited(false);
	//traceConfig.setLogLevel(traceConfig.LOGGING_LEVELS.DEBUG );
}

//message produced uses name-value pair format to send data
var encodeConfigNotify = exports.encodeConfigNotify = function (buffer, sessionId) {

	// NOTE - dynamic buffer allocation purposely not performed here - msg length is well-known size

	// set up header
	var msgHeaderLength = msgHeader.encode(buffer.slice(msgcon.TRANSPORT_HDR_LEN), sessionId);

	var msgBodyOffset = msgcon.TRANSPORT_HDR_LEN+msgHeaderLength;
	var msgBody = buffer.slice(msgBodyOffset);

	// track next position
	var offset = 0;

	// identify message as a ConfigNotify
	offset = msgUtil.writeInteger(msgcon.Opcode.ConfigNotify, msgBody, offset, 4); // value, offset, length

	// Instrumented
	msgBody[offset++] = (traceConfig.shouldInstrument()) ? 0x1 : 0x0;
	logger.logDebug(logLocation+'.encodeConfigNotify', 'instrumented:'+traceConfig.shouldInstrument());

	// bypassed
	msgBody[offset++] = (traceConfig.isShortCircuited()) ? 0x1 : 0x0;
	logger.logDebug(logLocation+'.encodeConfigNotify', 'bypassed:'+traceConfig.isShortCircuited());

	// Log level
	msgBody[offset++] = traceConfig.getLogLevel();
	logger.logDebug(logLocation+'.encodeConfigNotify', 'log level:'+traceConfig.getLogLevel());

	var sndLength = offset + msgHeaderLength + msgcon.TRANSPORT_HDR_LEN;
	transportHdr.encode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN), sndLength);

	logger.logDebug(logLocation+'.encodeConfigNotify', 'msg length:'+sndLength);

	var msg = {"buffer":buffer, "sndLength": sndLength};

	return msg;
}


//NOTE:  do not use allocateBuffer in this method. It logs debug msgs which will cause a recursion nightmare
// If the buffer is too small, we are not calculating its size correctly before passing it in
var encodeLogMessage = exports.encodeLogMessage = function (buffer, sessionId, severity, logMsg) {

	var msg = {"buffer":undefined, "sndLength": 0};

	try {
		// set up header
		var msgHeaderLength = msgHeader.encode(buffer.slice(msgcon.TRANSPORT_HDR_LEN), sessionId);

		var msgBodyOffset = msgcon.TRANSPORT_HDR_LEN+msgHeaderLength;
		var msgBody = buffer.slice(msgBodyOffset);

		// track next position
		var offset = 0;

		// identify message as a LogMessage
		offset = msgUtil.writeInteger(msgcon.Opcode.LogMessage, msgBody, offset, 4); // value, offset, length

		msgBody[offset++] = msgcon.DataType.String;
		offset = msgUtil.writeMsgString(severity, msgBody, offset);
		msgBody[offset++] = msgcon.DataType.String;
		offset = msgUtil.writeMsgString(logMsg, msgBody, offset);

		var sndLength = offset + msgHeaderLength + msgcon.TRANSPORT_HDR_LEN;
		transportHdr.encode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN), sndLength);

		msg.buffer = buffer;
		msg.sndLength = sndLength;

	} catch (err) {
		// what can go wrong here is that the buffer was too small.
		// This is a developer error so log it and catch the issue in development
		console.error(logLocation+'.encodeLogMessage - Unable to construct log message : ' + err.stack);
	}
	return msg;
}
