/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */
/*******************************************************************************
  Changes:

  - Date   -  UID  --------------------- Description ---------------------
  09/29/2016  ecl  BUG268560: Account for multi-byte characters when getting 
                   the number of bytes in a string.
 ******************************************************************************/

//*****************************
// Output Module
//*****************************

var logger = require('../trace-output-tcp'),
	msgcon = require('../protocol/constants'),
    transportHdr = require('../protocol/transportHeader'),
	msgUtil = require('../protocol/util'),
	msgHeader = require('../protocol/messageHeader'),
	metrics = require('./metrics');

var logLocation = 'sampleData';

var sendSampleData = exports.sendSampleData = function (buffer, sessionId, groupName, samples) {

	var id = metrics.metricGroups[groupName].id; // Get the group id
	var instanceNames = metrics.metricGroups[groupName].instanceNames; // Get the group instance names
	
	// set up header - pass the sessionId
	var msgHeaderLength = msgHeader.encode(buffer.slice(msgcon.TRANSPORT_HDR_LEN), sessionId);

	var msgBodyOffset = msgcon.TRANSPORT_HDR_LEN+msgHeaderLength;
	var msgBody = buffer.slice(msgBodyOffset);

	// track next position
	var offset = 0;

	// Sample data message.
	offset = msgUtil.writeInteger(msgcon.Opcode.SampleData, msgBody, offset, 4);
	
	var capacityNeeded = msgcon.TRANSPORT_HDR_LEN + msgHeaderLength + offset; 

	// 5 = 1 type byte + 1 short (2 bytes) + 2 type bytes after loops (so we don't have to do a separate check)
	capacityNeeded += 5;
	buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
	msgBody = buffer.slice(msgBodyOffset);

	// ID
	msgBody[offset++] = msgcon.DataType.DCH;
	offset = msgUtil.writeInteger(id, msgBody, offset, 2);

	// Hack alert: This only works because our Memory Management metrics
	// do not have repeated metric names (7th part).
	// Add a row for each group instance name.
	for (var instanceName in instanceNames) {

		// 6 = 2 type bytes + 1 int for string length (4 bytes) (so we don't have to do a separate check)
		capacityNeeded += 6 + msgUtil.getStringBytes(instanceName);
		buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
		msgBody = buffer.slice(msgBodyOffset);

		// More rows
		msgBody[offset++] = 0x1;

		// Add instance name.
		msgBody[offset++] = msgcon.DataType.String;
		offset = msgUtil.writeMsgString(instanceName, msgBody, offset);

		// Send all of the samples.
		for (var sample in samples) {

			// 9 = 1 type byte + 1 max data sample size (8 bytes) (so we don't have to do a separate check)
			capacityNeeded += 9;
			buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
			msgBody = buffer.slice(msgBodyOffset);
		
			var dataType = samples[sample].dataType;
			var value = samples[sample].value;
			logger.logDebug(logLocation+'.sendSampleData', (groupName+'\\'+instanceName+'\\'+sample+':'+value));

			// Add sample type and data.
			msgBody[offset++] = dataType;
	
			switch (dataType) {
			
				case msgcon.DataType.BYTE:
					capacityNeeded -= 7; // Subtract off the over allocated bytes (allocated 8 for data).
					msgBody[offset++] = value; // Byte
					break;
					
				case msgcon.DataType.Int16:
					capacityNeeded -= 6; // Subtract off the over allocated bytes (allocated 8 for data).
					offset = msgUtil.writeInteger(value, msgBody, offset, 2); // short
					break;
					
				case msgcon.DataType.Int32:
					capacityNeeded -= 4; // Subtract off the over allocated bytes (allocated 8 for data).
					offset = msgUtil.writeInteger(value, msgBody, offset, 4); // 32 bit
					break;
					
				case msgcon.DataType.Int64:
					offset = msgUtil.writeInteger(value, msgBody, offset, 8); // 64 bit
					break;
					
				case msgcon.DataType.Float:
					capacityNeeded -= 4; // Subtract off the over allocated bytes (allocated 8 for data).
					offset = msgUtil.writeFloat(value, msgBody, offset); // 32 bit
					break;
					
				case msgcon.DataType.Double:
					offset = msgUtil.writeDouble(value, msgBody, offset); // 64 bit
					break;
					
				default:
					//TODO what needs to be done here??? 
					logger.logError(logLocation+'.sendSampleData', 'Unsupported encoding:'+dataType);
			}
		}
	}
	
	// No more rows, End message.
	msgBody[offset++] = 0;
	msgBody[offset++] = msgcon.DataType.END;
	
	var sndLength = offset + msgHeaderLength + msgcon.TRANSPORT_HDR_LEN;
	transportHdr.encode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN), sndLength);

	logger.logDebug(logLocation+'.sendSampleData', 'msg length:'+sndLength);

	var msg = {"buffer":buffer, "sndLength": sndLength};

	return (msg);
}

