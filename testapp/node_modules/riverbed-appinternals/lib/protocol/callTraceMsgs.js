/* ****************************
** Copyright (c) 2015        **
** Riverbed Technology, Inc. **
** All Rights Reserved.      **
** ************************* */
/*******************************************************************************
  Changes:

  - Date   -  UID  --------------------- Description ---------------------
  09/29/2016  ecl  BUG268560: Account for multi-byte characters when getting 
                   the number of bytes in a string.
 ******************************************************************************/

"use strict";

var logger = require('../trace-output-tcp'),
	transportHdr = require('../protocol/transportHeader'),
	msgHeader = require('../protocol/messageHeader'),
	msgUtil = require('../protocol/util'),
	msgcon = require('../protocol/constants'),
	traceProps = require('../protocol/trace-props');

//-----------------------------
//Internal Constants
//-----------------------------

var logLocation = 'callTraceMsgs';

//-----------------------------
//External Functions
//-----------------------------

//Sample traceData
//var traceStartData = {
//		type		: 'start',
//		// transaction id
//		txId 		: 0,
//		category   	: 'generic',
//		file 		: 'Collection',
//		method		: 'find',
//		time		: Date.now(),
//		props		: [{name : 'async.id', value : '1234'}, {name : 'property2', value : 'value1'}, {name : 'property2', value : 'value2'}]
//};
//var traceCompleteData = {
//		type			: 'end',
//		// transaction id
//		txId 			: 0,
//		time			: Date.now(),
//		props			: [{name : 'httpStatus', value : '404'},…],
//		exceptions		: [“string1”,”string2”,…]	
//};

// message produced uses name-value pair format to send data
var encodeCallStartNVP = exports.encodeCallStartNVP = function (buffer, sessionId, traceData) {

	// set up header
	var msgHeaderLength = msgHeader.encode(buffer.slice(msgcon.TRANSPORT_HDR_LEN), sessionId);

	var msgBodyOffset = msgcon.TRANSPORT_HDR_LEN+msgHeaderLength;
	var msgBody = buffer.slice(msgBodyOffset);

	// track next position
	var offset = 0;

	// identify message as a CallStart
	offset = msgUtil.writeInteger(msgcon.Opcode.CallStart, msgBody, offset, 4); // value, offset, length

	// msg format is name-value pairs
	msgBody[offset++] = msgcon.INVALID_HANDLE_VALUE;
	
	// NOTE: strategy is to validate buffer capacity for data that is user-application dependent.
	// +offset = stuff already written to msgBody
    // Not using msgUtil.getStringBytes for the trace properties since we know they are single byte characters.
	// 51 = 10 type bytes (for 5 property key/value pairs) + 10 ints for property key/value string lengths (10*4=40 bytes) + following END byte (so we don't have to do a separate check)
	var capacityNeeded = msgcon.TRANSPORT_HDR_LEN + msgHeaderLength + offset+ 51 + msgcon.TraceProps.txId.length + msgUtil.getStringBytes(String(traceData.txId))
			+ msgcon.TraceProps.category.length + msgUtil.getStringBytes(traceData.category) + msgcon.TraceProps.file.length + msgUtil.getStringBytes(traceData.file)
			+ msgcon.TraceProps.method.length + msgUtil.getStringBytes(traceData.method) + msgcon.TraceProps.time.length + msgUtil.getStringBytes(String(traceData.time));
	buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
	msgBody = buffer.slice(msgBodyOffset);

	//TODO - trace file permits precision up to a signed 64-bit number, Yichong's test file writes an int (32 bit)
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(msgcon.TraceProps.txId, msgBody, offset);
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(String(traceData.txId), msgBody, offset, 4); // value, offset, length
	
	//write category as String (Name:'category': Value:'generic')
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(msgcon.TraceProps.category, msgBody, offset);
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(traceData.category, msgBody, offset);

	//write file name as String (Name:'className': Value:'http')
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(msgcon.TraceProps.file, msgBody, offset);
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(traceData.file, msgBody, offset);
	
	//write function name as String (Name:'methodName': Value:'tier1Callback')
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(msgcon.TraceProps.method, msgBody, offset);
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(traceData.method, msgBody, offset);

	// we can't write longs in Javascript; all numbers are double precision floats (64-bit) 
	// time is a Date object - get # msecs since 1970 and convert to string
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(msgcon.TraceProps.time, msgBody, offset);
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(String(traceData.time), msgBody, offset); // value, offset
	
	// properties (an array of name-value pairs)
	
	if ('props' in traceData) {
		traceData.props.forEach( function (arrayItem) {
			// 10 = 2 type bytes + 2 ints for string length (8 bytes)
			capacityNeeded += 10 + msgUtil.getStringBytes(arrayItem.name) + msgUtil.getStringBytes(String(arrayItem.value));		
			buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
			msgBody = buffer.slice(msgBodyOffset);

			msgBody[offset++] = msgcon.DataType.String;
			offset = msgUtil.writeMsgString(arrayItem.name, msgBody, offset);
			msgBody[offset++] = msgcon.DataType.String;
			offset = msgUtil.writeMsgString(arrayItem.value.toString(), msgBody, offset); // value, offset
		});
	}
		
	// End message
	msgBody[offset++] = msgcon.DataType.END;

	var sndLength = offset + msgHeaderLength + msgcon.TRANSPORT_HDR_LEN;
	transportHdr.encode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN), sndLength);

    // Have an issue calculating capacity.
    if ((capacityNeeded - sndLength) != 0) {

        logger.logWarn(logLocation + '.encodeCallStartNVP', 'msg length:' + sndLength + ' capacityNeeded: ' + capacityNeeded + ' diff = ' + (capacityNeeded - sndLength));
    }
    
	logger.logDebug(logLocation+'.encodeCallStartNVP', 'msg length:'+sndLength);

	var msg = {"buffer":buffer, "sndLength": sndLength};

	return msg;
}

//message produced uses name-value pair format to send data
var encodeCallCompleteNVP = exports.encodeCallCompleteNVP = function (buffer, sessionId, traceData) {

	// set up header
	var msgHeaderLength = msgHeader.encode(buffer.slice(msgcon.TRANSPORT_HDR_LEN), sessionId);

	var msgBodyOffset = msgcon.TRANSPORT_HDR_LEN+msgHeaderLength;
	var msgBody = buffer.slice(msgBodyOffset);

	// track next position
	var offset = 0;

	// identify message as a CallComplete
	offset = msgUtil.writeInteger(msgcon.Opcode.CallComplete, msgBody, offset, 4); // value, offset, length

	// Exception flag
	var gotExceptions = false;
	if ('exceptions' in traceData && traceData.exceptions.length > 0) {
		msgBody[offset++] = 0x1;
		gotExceptions = true;
	} else {
		msgBody[offset++] = 0x0;
	}
	
	// msg format is name-value pairs
	msgBody[offset++] = msgcon.INVALID_HANDLE_VALUE;
	
	//TODO - trace file permits precision up to a signed 64-bit number, Yichong's test file writes an int (32 bit)
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(msgcon.TraceProps.txId, msgBody, offset);
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(String(traceData.txId), msgBody, offset, 4); // value, offset, length
	
	// we can't write longs in Javascript; all numbers are double precision floats (64-bit) 
	// time is a Date object - get # msecs since 1970 and convert to string
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(msgcon.TraceProps.time, msgBody, offset);
	msgBody[offset++] = msgcon.DataType.String;
	offset = msgUtil.writeMsgString(String(traceData.time), msgBody, offset); // value, offset
	//time=msecs      offset = msgUtil.writeMsgString(traceData.time.toString(), msgBody, offset); // value, offset

	// NOTE: strategy is to validate buffer capacity for data that is user-application dependent.
	// +offset = stuff already written to msgBody
    // + following END byte (so we don't have to do a separate check)
	var capacityNeeded = msgcon.TRANSPORT_HDR_LEN + msgHeaderLength + offset + 1;

	// properties (an array of name-value pairs)
	if ('props' in traceData) {
		traceData.props.forEach( function (arrayItem) {

			// 10 = 2 type bytes + 2 ints for string length (8 bytes)
			capacityNeeded += 10 + msgUtil.getStringBytes(arrayItem.name) + msgUtil.getStringBytes(String(arrayItem.value));
			buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
			msgBody = buffer.slice(msgBodyOffset);

			msgBody[offset++] = msgcon.DataType.String;
			offset = msgUtil.writeMsgString(arrayItem.name, msgBody, offset);
			msgBody[offset++] = msgcon.DataType.String;
			offset = msgUtil.writeMsgString(arrayItem.value.toString(), msgBody, offset); // value, offset
		});
	}

	if (gotExceptions) {
		// End message
		msgBody[offset++] = msgcon.DataType.END;
		capacityNeeded++;

		traceData.exceptions.forEach( function (arrayItem) {

			// 19 = 2 type bytes + 2 ints for string length (8 bytes) + 9 bytes ('exception')
			capacityNeeded += 19 + msgUtil.getStringBytes(String(arrayItem));
			buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
			msgBody = buffer.slice(msgBodyOffset);

			msgBody[offset++] = msgcon.DataType.String;
			offset = msgUtil.writeMsgString("exception", msgBody, offset);
			msgBody[offset++] = msgcon.DataType.String;
			offset = msgUtil.writeMsgString(arrayItem.toString(), msgBody, offset); // value, offset
		});
	}
	
	// End message
	msgBody[offset++] = msgcon.DataType.END;

	var sndLength = offset + msgHeaderLength + msgcon.TRANSPORT_HDR_LEN;
	transportHdr.encode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN), sndLength);

    // Have an issue calculating capacity.
    if ((capacityNeeded - sndLength) != 0) {
        
        logger.logWarn(logLocation + '.encodeCallCompleteNVP', 'msg length:' + sndLength + ' capacityNeeded: ' + capacityNeeded + ' diff = ' + (capacityNeeded - sndLength));
	}
    
	logger.logDebug(logLocation+'.encodeCallCompleteNVP', 'msg length:'+sndLength);

	var msg = {"buffer":buffer, "sndLength": sndLength};

	return msg;
}

//message produced uses name-value pair format to send data
var encodeCreateTraceProperties = exports.encodeCreateTraceProperties = function (buffer, sessionId, envProps) {

	var bufferCapacity = buffer.length;
	
	// set up header
	var msgHeaderLength = msgHeader.encode(buffer.slice(msgcon.TRANSPORT_HDR_LEN), sessionId);

	var msgBodyOffset = msgcon.TRANSPORT_HDR_LEN+msgHeaderLength;
	var msgBody = buffer.slice(msgBodyOffset);

	// track next position
	var offset = 0;

	// identify message as a CreateTraceProperties
	offset = msgUtil.writeInteger(msgcon.Opcode.CreateTraceProperties, msgBody, offset, 4); // value, offset, length

	// msg format is name-value pairs
	msgBody[offset++] = msgcon.INVALID_HANDLE_VALUE;
	
	// We know what is being sent - on the off chance someone changes a file and forgets to increase the buffer size, 
	// this will not fail on-site.
    //  + following 2 END bytes (so we don't have to do a separate check)
	var capacityNeeded = msgcon.TRANSPORT_HDR_LEN + msgHeaderLength + offset + 2; 
	
	// env properties 
	for(var property in envProps) {
		
		// 10 = 2 type bytes + 2 ints for string length (8 bytes)
		capacityNeeded += 10 + msgUtil.getStringBytes(property) + msgUtil.getStringBytes(String(envProps[property]));
		buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
		msgBody = buffer.slice(msgBodyOffset);

		msgBody[offset++] = msgcon.DataType.String;
		offset = msgUtil.writeMsgString(property, msgBody, offset);
		msgBody[offset++] = msgcon.DataType.String;
		offset = msgUtil.writeMsgString(envProps[property].toString(), msgBody, offset); // value, offset
	}

	// End envProps
	msgBody[offset++] = msgcon.DataType.END;

	// trace properties send as list of strings
	traceProps.TraceProperties.forEach( function (arrayItem) {

		// 5 = type byte + string length (4 bytes)
		capacityNeeded += 5 + msgUtil.getStringBytes(arrayItem);
		buffer = msgUtil.checkBufferCapacity(buffer, capacityNeeded);
		msgBody = buffer.slice(msgBodyOffset);

		msgBody[offset++] = msgcon.DataType.String;
		offset = msgUtil.writeMsgString(arrayItem, msgBody, offset);
	});

	// End message
	msgBody[offset++] = msgcon.DataType.END;

	var sndLength = offset + msgHeaderLength + msgcon.TRANSPORT_HDR_LEN;
	transportHdr.encode(buffer.slice(0, msgcon.TRANSPORT_HDR_LEN), sndLength);

    // Have an issue calculating capacity.
    if ((capacityNeeded - sndLength) != 0) {

        logger.logWarn(logLocation + '.encodeCreateTraceProperties', 'msg length:' + sndLength + ' capacityNeeded: ' + capacityNeeded + ' diff = ' + (capacityNeeded - sndLength));
    }
    
	logger.logDebug(logLocation+'.encodeCreateTraceProperties', 'msg length:'+sndLength);

	var msg = {"buffer":buffer, "sndLength": sndLength};

	return msg;
}

